% Based on http://nbviewer.jupyter.org/github/ipython/nbconvert-examples/blob/master/citations/Tutorial.ipynb , authored by Brian E. Granger
    % Declare the document class
    \documentclass[landscape,letterpaper,10pt,english]{article}


    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8x]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Tutorial-Solving\_the\_Scalar\_Wave\_Equation\_with\_NumPy}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
% Start the section counter at -1, so the Table of Contents is Section 0
   \setcounter{section}{-2}
% Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }

    % Slightly bigger margins than the latex defaults
    \geometry{verbose,tmargin=0.5in,bmargin=0.5in,lmargin=0.5in,rmargin=0.5in}


\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{nrpy-tutorial-solving-the-scalar-wave-equation-with-numpy}{%
\section{\texorpdfstring{NRPy+ Tutorial: Solving the Scalar Wave
Equation with
\texttt{NumPy}}{NRPy+ Tutorial: Solving the Scalar Wave Equation with NumPy}}\label{nrpy-tutorial-solving-the-scalar-wave-equation-with-numpy}}

\hypertarget{authors-zach-etienne-patrick-nelson-terrence-pierre-jacques-thiago-assumpuxe7uxe3o-leo-werneck-brandon-clark}{%
\subsection{Authors: Zach Etienne, Patrick Nelson, Terrence Pierre
Jacques, Thiago Assumpção, Leo Werneck, Brandon
Clark}\label{authors-zach-etienne-patrick-nelson-terrence-pierre-jacques-thiago-assumpuxe7uxe3o-leo-werneck-brandon-clark}}

(\emph{Note on Authors}: Zach wrote the NRPy+ infrastructure, as well as
this notebook and its Python code; Patrick wrote the first version of
the NRPy+-based Einstein Toolkit thorns for solving the scalar wave
equation in 2018; Terrence rewrote these thorns to latest NRPy+
standards in 2020, along the lines of the
\href{Tutorial-BaikalETK.ipynb}{\texttt{BaikalETK} thorns}; Thiago
extended the scalar wave initial data infrastructure and contributed
fixes to the original NRPy+ scalar wave notebooks; Leo created the
boundary condition animation below; and Brandon established NRPy+
notebook formatting standards.)

This notebook was first written as a tutorial to introduce NRPy+ during
the 2020 Einstein Toolkit Workshop.

\hypertarget{in-this-tutorial-we-will-construct-and-validate-a-code-that-solves-the-scalar-wave-equation-partial_t2-u-c2-nabla2-u-using-numpy-to-both-review-the-basic-components-of-a-numerical-pde-solver-and-motivate-the-use-of-nrpy}{%
\subsection{\texorpdfstring{In this tutorial we will construct and
validate a code that solves the scalar wave equation
\(\partial_t^2 u = c^2 \nabla^2 u\) using \texttt{NumPy}, to both review
the basic components of a numerical PDE solver and motivate the use of
NRPy+}{In this tutorial we will construct and validate a code that solves the scalar wave equation \textbackslash partial\_t\^{}2 u = c\^{}2 \textbackslash nabla\^{}2 u using NumPy, to both review the basic components of a numerical PDE solver and motivate the use of NRPy+}}\label{in-this-tutorial-we-will-construct-and-validate-a-code-that-solves-the-scalar-wave-equation-partial_t2-u-c2-nabla2-u-using-numpy-to-both-review-the-basic-components-of-a-numerical-pde-solver-and-motivate-the-use-of-nrpy}}

This notebook was written to explicitly outline the basic algorithms for
numerically solving
\href{https://en.wikipedia.org/wiki/Hyperbolic_partial_differential_equation}{hyperbolic
PDEs}, \textbf{including Einstein's equations of general relativity in
e.g., the BSSN formalism}.

While the codes here are written by hand, the objective of the notebook
is motivate the use of NRPy+, which can be used to generate much of this
code either \emph{automatically} or from validated templates, greatly
reducing the possibility of human error.

\textbf{Notebook Status:} Validated

\textbf{Validation Notes:} The code developed in this tutorial notebook
has been confirmed to converge to the exact solution at the expected
rate, as documented below.

    \hypertarget{table-of-contents}{%
\section{Table of Contents}\label{table-of-contents}}

\[\label{toc}\]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[prereqs]{Step 0}: Prerequisites \& Additional Reading
\item
  \hyperref[intro]{Step 1}: Introduction: The scalar wave equation

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    \hyperref[problem_statement]{Step 1.a}: Mathematical problem
    statement
  \item
    \hyperref[solution]{Step 1.b}: Chosen solution to the scalar wave
    equation
  \item
    \hyperref[initial_condition]{Step 1.c}: Initial condition
  \end{enumerate}
\item
  \hyperref[mol]{Step 2}: The Method of Lines (MoL)
\item
  \hyperref[basicalg]{Step 3}: \texttt{NumPy} Implementation: Basic
  Algorithm

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    \hyperref[numgrid_freeparams]{Step 3.a}: Set up the numerical grid
    and free parameters
  \item
    \hyperref[numpy_id]{Step 3.b}: Set up the initial data
  \item
    \hyperref[numpy_gfs]{Step 3.c}: Allocate memory for the
    gridfunctions storing \(u\) and \(v\), and define the indexing macro
    function
  \item
    \hyperref[numpy_rhss]{Step 3.d}: Define the right-hand sides of the
    PDEs
  \item
    \hyperref[numpy_bcs]{Step 3.e}: Boundary Conditions
  \item
    \hyperref[numpy_mol]{Step 3.f}: The Method of Lines
  \item
    \hyperref[numpy_driver]{Step 3.g}: The main driver function
  \end{enumerate}
\item
  \hyperref[too_slow]{Step 4}: Argh, the code is SLOW! Why use NRPy+
  instead?
\item
  \hyperref[error_analysis]{Step 5}: Error analysis \& code validation:
  Confirming numerical errors converge to zero at the expected rate
\item
  \hyperref[student_exercises]{Step 6}: Exercises for students
\item
  \hyperref[latex_pdf_output]{Step 7}: Output this notebook to
  \(\LaTeX\)-formatted PDF file
\end{enumerate}

    \hypertarget{step-0-prerequisites-additional-reading-back-to-top}{%
\section{\texorpdfstring{Step 0: Prerequisites \& Additional Reading
{[}Back to
\hyperref[toc]{top}{]}}{Step 0: Prerequisites \& Additional Reading {[}Back to {]}}}\label{step-0-prerequisites-additional-reading-back-to-top}}

\[\label{prereqs}\]

This tutorial assumes basic familiarity with computer programming,
undergraduate mathematics, and computational physics or numerical
analysis.

For additional reading, please consult the following links:

\begin{itemize}
\tightlist
\item
  \href{https://etienneresearch.com/MATH521-f2018/notes__additional_reading.html}{Online
  Resources for Numerical Analysis \& Basic Mathematics}
\item
  \href{http://www.numerical.recipes/}{Numerical Recipes in C} Feel free
  to use the \emph{free} ``obsolete'' (but not really!) versions. Note
  that Numerical Recipes was written by numerical relativists!
\end{itemize}

    \hypertarget{step-1-introduction-the-scalar-wave-equation-back-to-top}{%
\section{\texorpdfstring{Step 1: Introduction: The scalar wave equation
{[}Back to
\hyperref[toc]{top}{]}}{Step 1: Introduction: The scalar wave equation {[}Back to {]}}}\label{step-1-introduction-the-scalar-wave-equation-back-to-top}}

\[\label{intro}\]

We will write a Python code (based in \href{https://numpy.org/}{NumPy})
to numerically solve the scalar wave equation

\[\partial_t^2 u(t,x,y,z) = c^2 \nabla^2 u(t,x,y,z),\]

given initial conditions \(u(t=t_0,x,y,z)\).

\hypertarget{step-1.a-mathematical-problem-statement-back-to-top}{%
\subsection{\texorpdfstring{Step 1.a: Mathematical problem statement
{[}Back to
\hyperref[toc]{top}{]}}{Step 1.a: Mathematical problem statement {[}Back to {]}}}\label{step-1.a-mathematical-problem-statement-back-to-top}}

\[\label{problem_statement}\]

We will numerically solve the scalar wave equation as an
\href{https://en.wikipedia.org/wiki/Initial_value_problem}{initial value
problem} in Cartesian coordinates: \[\partial_t^2 u = c^2 \nabla^2 u,\]
where \(u\) (the amplitude of the wave) is a function of time and space:
\(u = u(t,x,y,...)\) (spatial dimension as-yet unspecified) and \(c\) is
the wave speed, subject to some initial condition

\[u(0,x,y,...) = f(x,y,...)\]

and suitable spatial boundary conditions (we'll stick with simple
extrapolation boundary conditions at first).

As described in the next section, we will find it quite useful to define
\[v(t,x,y,...) = \partial_t u(t,x,y,...).\]

In this way, the second-order PDE is reduced to a set of two coupled
first-order PDEs in time

\begin{align}
\partial_t u &= v \\
\partial_t v &= c^2 \nabla^2 u.
\end{align}

We will use NRPy+ to generate efficient C codes capable of generating
both initial data \(u(0,x,y,...) = f(x,y,...)\);
\(v(0,x,y,...)=g(x,y,...)\), as well as finite-difference expressions
for the right-hand sides of the above expressions. These expressions are
needed within the \emph{Method of Lines} to ``integrate'' the solution
forward in time.

    \hypertarget{step-1.b-chosen-solution-to-the-scalar-wave-equation-back-to-top}{%
\subsection{\texorpdfstring{Step 1.b: Chosen solution to the scalar wave
equation {[}Back to
\hyperref[toc]{top}{]}}{Step 1.b: Chosen solution to the scalar wave equation {[}Back to {]}}}\label{step-1.b-chosen-solution-to-the-scalar-wave-equation-back-to-top}}

\[\label{solution}\]

Here we will implement the spherical Gaussian solution to the scalar
wave equation, which consists of ingoing and outgoing wave fronts:
\begin{align}
u(r,t) &= u_{\rm out}(r,t) + u_{\rm in}(r,t) + u_{\rm offset},\ \ \text{where}\\
u_{\rm out}(r,t) &=\frac{r-ct}{r} \exp\left[\frac{-(r-ct)^2}{2 \sigma^2}\right] \\
u_{\rm in}(r,t) &=\frac{r+ct}{r} \exp\left[\frac{-(r+ct)^2}{2 \sigma^2}\right] \\
\end{align} where \(c\) is the wavespeed, \(u_{\rm offset}\) is a freely
specifiable constant offset, \(\sigma\) is the width of the Gaussian
(i.e., the ``standard deviation''). Next we'll demonstrate using SymPy
(a computer algebra system written in Python, on which NRPy+ depends)
that the above indeed is a solution to the scalar wave equation.

In Cartesian coordinates we have \[
\partial_t^2 u(t,x,y,z) = c^2 \nabla^2 u(t,x,y,z),
\] and we know that \[
r = \sqrt{x^2+y^2+z^2},
\] which we implement below using \href{https://www.sympy.org/}{SymPy},
the Python computer algebra package that NRPy+ uses.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{sympy} \PY{k}{as} \PY{n+nn}{sp}  \PY{c+c1}{\PYZsh{} SymPy: The Python computer algebra package upon which NRPy+ depends}

\PY{c+c1}{\PYZsh{} Declare independent variables t,x,y,z as (real\PYZhy{}valued) SymPy symbols}
\PY{n}{t}\PY{p}{,}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{z} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{symbols}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{t x y z}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{real}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Declare the parameters c, sigma, and u\PYZus{}offset as (real\PYZhy{}valued) SymPy symbols as well.}
\PY{c+c1}{\PYZsh{}   In NRPy+ we\PYZsq{}d declare these as NRPy+ *parameters*}
\PY{n}{c}\PY{p}{,} \PY{n}{sigma}\PY{p}{,} \PY{n}{u\PYZus{}offset} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{symbols}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c sigma u\PYZus{}offset}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{real}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Then define r:}
\PY{n}{r} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{n}{y}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{n}{z}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Next set up the solution u(t,x,y,z):}
\PY{c+c1}{\PYZsh{} First the outgoing wave}
\PY{n}{u\PYZus{}out} \PY{o}{=} \PY{p}{(}\PY{n}{r} \PY{o}{\PYZhy{}} \PY{n}{c}\PY{o}{*}\PY{n}{t}\PY{p}{)}\PY{o}{/}\PY{n}{r} \PY{o}{*} \PY{n}{sp}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{r} \PY{o}{\PYZhy{}} \PY{n}{c}\PY{o}{*}\PY{n}{t}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{/} \PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\PY{c+c1}{\PYZsh{} ... and then the ingoing wave}
\PY{n}{u\PYZus{}in}  \PY{o}{=} \PY{p}{(}\PY{n}{r} \PY{o}{+} \PY{n}{c}\PY{o}{*}\PY{n}{t}\PY{p}{)}\PY{o}{/}\PY{n}{r} \PY{o}{*} \PY{n}{sp}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{r} \PY{o}{+} \PY{n}{c}\PY{o}{*}\PY{n}{t}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{/} \PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}

\PY{n}{u\PYZus{}exact} \PY{o}{=} \PY{n}{u\PYZus{}out} \PY{o}{+} \PY{n}{u\PYZus{}in} \PY{o}{+} \PY{n}{u\PYZus{}offset}

\PY{c+c1}{\PYZsh{} ... and then v, which is the time derivative of u:}
\PY{n}{v\PYZus{}exact} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}exact}\PY{p}{,} \PY{n}{t}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Here is a visualization of this solution over time \(u_{\rm exact}(t)\)
in the \(x-z\) plane, generated using
\href{https://matplotlib.org/}{matplotlib}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{IFrame}
\PY{c+c1}{\PYZsh{} Youtube}
\PY{n}{IFrame}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://www.youtube.com/embed/TJOo2JIW53g?rel=0\PYZam{}amp;controls=0\PYZam{}amp;showinfo=0}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+m+mi}{560}\PY{p}{,}\PY{l+m+mi}{315}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
<IPython.lib.display.IFrame at 0x7f653d937bb0>
\end{Verbatim}
\end{tcolorbox}
        
    Now let's confirm the solution solves the PDE: \[
\partial_t^2 u(t,x,y,z) = c^2 \nabla^2 u(t,x,y,z),
\] by confirming that \[
\partial_t^2 u(t,x,y,z) - c^2 \nabla^2 u(t,x,y,z) = 0,
\] using SymPy to compute the second derivatives of \(u\) symbolically.
To make it easier for SymPy to simplify the resulting expression, we
will split up the above equation into:

\[
\partial_t^2 (u_{\rm in} + u_{\rm out} + u_{\rm offset}) - c^2 \nabla^2 (u_{\rm in} + u_{\rm out} + u_{\rm offset}) = 0,
\] and confirm that \begin{align}
\partial_t^2 u_{\rm in} - c^2 \nabla^2 u_{\rm in} &= 0 \\
\partial_t^2 u_{\rm out} - c^2 \nabla^2 u_{\rm out} &= 0 \\
\partial_t^2 u_{\rm offset} - c^2 \nabla^2 u_{\rm offset} &= 0,
\end{align} which must be the case since the scalar wave equation is a
\href{https://en.wikipedia.org/wiki/Partial_differential_equation}{linear
PDE}, in which each of the waves (ingoing, outgoing, and constant) must
satisfy the wave equation separately:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Finally confirm that the solution indeed solves the PDE,}
\PY{c+c1}{\PYZsh{}   by subtracting the left\PYZhy{}hand\PYZhy{}side from the right\PYZhy{}hand\PYZhy{}side}
\PY{c+c1}{\PYZsh{}   of the equation and simplifying; we should get zero}
\PY{n}{scalarwave\PYZus{}lhs\PYZus{}in}  \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}in}\PY{p}{,}  \PY{n}{t}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}lhs\PYZus{}out} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}out}\PY{p}{,} \PY{n}{t}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}lhs\PYZus{}ost} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}offset}\PY{p}{,} \PY{n}{t}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}rhs\PYZus{}in}  \PY{o}{=} \PY{n}{c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}in}\PY{p}{,}  \PY{n}{x}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}in}\PY{p}{,}  \PY{n}{y}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}in}\PY{p}{,}  \PY{n}{z}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}rhs\PYZus{}out} \PY{o}{=} \PY{n}{c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}out}\PY{p}{,} \PY{n}{x}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}out}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}out}\PY{p}{,} \PY{n}{z}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}rhs\PYZus{}ost} \PY{o}{=} \PY{n}{c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}offset}\PY{p}{,} \PY{n}{x}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}offset}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{n}{sp}\PY{o}{.}\PY{n}{diff}\PY{p}{(}\PY{n}{u\PYZus{}offset}\PY{p}{,} \PY{n}{z}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}

\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}in}  \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{simplify}\PY{p}{(}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}in}  \PY{o}{\PYZhy{}} \PY{n}{scalarwave\PYZus{}rhs\PYZus{}in}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}out} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{simplify}\PY{p}{(}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}out} \PY{o}{\PYZhy{}} \PY{n}{scalarwave\PYZus{}rhs\PYZus{}out}\PY{p}{)}
\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}ost} \PY{o}{=} \PY{n}{sp}\PY{o}{.}\PY{n}{simplify}\PY{p}{(}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}ost} \PY{o}{\PYZhy{}} \PY{n}{scalarwave\PYZus{}rhs\PYZus{}ost}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{(rhs \PYZhy{} lhs) = }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}in}\PY{o}{+}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}out}\PY{o}{+}\PY{n}{scalarwave\PYZus{}lhs\PYZus{}minus\PYZus{}rhs\PYZus{}ost}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
(rhs - lhs) = 0
    \end{Verbatim}

    \hypertarget{step-1.c-initial-condition-back-to-top}{%
\subsection{\texorpdfstring{Step 1.c: Initial Condition {[}Back to
\hyperref[toc]{top}{]}}{Step 1.c: Initial Condition {[}Back to {]}}}\label{step-1.c-initial-condition-back-to-top}}

\[\label{initial_condition}\]

We will choose the above solution at \(t=0\), \(u(t=0,x,y,z)\), as our
initial data and adopt the Method of Lines (described next) to advance
the solution forward in time (i.e., solve the initial value problem).

    \hypertarget{step-2-the-method-of-lines-mol-back-to-top}{%
\section{\texorpdfstring{Step 2: The Method of Lines (MoL) {[}Back to
\hyperref[toc]{top}{]}}{Step 2: The Method of Lines (MoL) {[}Back to {]}}}\label{step-2-the-method-of-lines-mol-back-to-top}}

\[\label{mol}\]

Once we have set our initial conditions (usually referred to as our
``initial data''), we ``evolve it forward in time'', using the
\href{https://reference.wolfram.com/language/tutorial/NDSolveMethodOfLines.html}{Method
of Lines}. In short, the Method of Lines enables us to handle 1. the
\textbf{spatial derivatives} of an initial value problem PDE using
\textbf{standard finite difference approaches}, and 2. the
\textbf{temporal derivatives} of an initial value problem PDE using
\textbf{standard strategies for solving ordinary differential equations
(ODEs)}, so long as the initial value problem PDE can be written in the
form \[\partial_t \vec{f} = \mathbf{M}\ \vec{f},\] where \(\mathbf{M}\)
is an \(N\times N\) matrix filled with differential operators that act
on the \(N\)-element column vector \(\vec{f}\). \(\mathbf{M}\) may not
contain \(t\) or time derivatives explicitly; only \emph{spatial}
partial derivatives are allowed to appear inside \(\mathbf{M}\). The
scalar wave equation as written in the
\href{Tutorial-ScalarWave.ipynb}{previous module} \begin{equation}
\partial_t 
\begin{bmatrix}
u \\
v 
\end{bmatrix}=
\begin{bmatrix}
0 & 1 \\
c^2 \nabla^2  & 0 
\end{bmatrix}
\begin{bmatrix}
u \\
v 
\end{bmatrix}
\end{equation} satisfies this requirement.

Thus we can treat the spatial derivatives \(\nabla^2 u\) of the scalar
wave equation using \textbf{standard finite-difference approaches}, and
the temporal derivatives \(\partial_t u\) and \(\partial_t v\) using
\textbf{standard approaches for solving ODEs}.

Here we will apply the highly robust
\href{https://en.wikipedia.org/wiki/Runge\%E2\%80\%93Kutta_methods}{explicit
Runge-Kutta fourth-order scheme} (RK4), used widely for numerically
solving ODEs, to ``march'' (integrate) the solution vector \(\vec{f}\)
forward in time from its initial value (``initial data'').

    Here's how MoL works.

The RK4 method is usually presented for solving the ODE \[
y'(t) = f(y,t)
\] as follows. Given initial data \(y(t_0)=y_0\), one can construct the
solution at any later time via the algorithm: \begin{align}
k_1 &= f(y_n, t_n), \\
k_2 &= f(y_n + \frac{1}{2}\Delta tk_1, t_n + \frac{\Delta t}{2}), \\
k_3 &= f(y_n + \frac{1}{2}\Delta tk_2, t_n + \frac{\Delta t}{2}), \\
k_4 &= f(y_n + \Delta tk_3, t_n + \Delta t), \\
y_{n+1} &= y_n + \frac{1}{6}\Delta t(k_1 + 2k_2 + 2k_3 + k_4) + \mathcal{O}\big((\Delta t)^5\big).
\end{align}

Our PDE involves two variables \(u\) and \(v\), and the algorithm
generalizes in exactly the same manner as it would if we were solving a
system of coupled ODEs with two variables. Further our PDE does not
contain explicit time dependence, which simplifies the algorithm a bit:
\begin{align}
k_{1,u} &= f_u(u_n,v_n) = f_u(v_n) = v_n, \\
k_{1,v} &= f_v(u_n,v_n) = f_v(u_n) = c^2\nabla^2 u_n, \\
k_{2,u} &= f_u\left(v_n + \frac{1}{2}\Delta tk_{1,v}\right) = v_n + \frac{1}{2}\Delta tk_{1,v}\\
k_{2,v} &= f_v\left(u_n + \frac{1}{2}\Delta tk_{1,u}\right) = c^2\nabla^2 \left(u_n + \frac{1}{2}\Delta tk_{1,u}\right), \\
k_{3,u} &= f_u\left(v_n + \frac{1}{2}\Delta tk_{2,v}\right) = v_n + \frac{1}{2}\Delta tk_{2,v}\\
k_{3,v} &= f_v\left(u_n + \frac{1}{2}\Delta tk_{2,u}\right) = c^2\nabla^2 \left(u_n + \frac{1}{2}\Delta tk_{2,u}\right), \\
k_{4,u} &= f_u(v_n + \Delta tk_{3,v}) = v_n + \Delta tk_{3,v}\\
k_{4,v} &= f_v(u_n + \Delta tk_{3,u}) = c^2\nabla^2 \left(u_n + \Delta tk_{3,u}\right), \\
u_{n+1} &= u_n + \frac{1}{6}\Delta t(k_{1,u} + 2k_{2,u} + 2k_{3,u} + k_{4,u}) + \mathcal{O}\big((\Delta t)^5\big)\\
v_{n+1} &= v_n + \frac{1}{6}\Delta t(k_{1,v} + 2k_{2,v} + 2k_{3,v} + k_{4,v}) + \mathcal{O}\big((\Delta t)^5\big).
\end{align}

Thus, given initial data \(u_0\) and \(v_0\), we can use the above
algorithm to advance the solution forward in time by one timestep, to
\(u_1\) and \(v_1\). Recall the \(\nabla^2 u\) terms in the above
expressions are computed using finite-difference derivatives. Since
finite-difference derivatives require neighboring points be evaluated,
we only evaluate the \(k_i\)'s in the interior of the grid; at each step
we apply boundary conditions to fill in the outermost neighboring points
(called ghost zones).

    \hypertarget{step-3-numpy-implementation-basic-algorithm-back-to-top}{%
\section{\texorpdfstring{Step 3: \texttt{NumPy} Implementation: Basic
Algorithm {[}Back to
\hyperref[toc]{top}{]}}{Step 3: NumPy Implementation: Basic Algorithm {[}Back to {]}}}\label{step-3-numpy-implementation-basic-algorithm-back-to-top}}

\[\label{basicalg}\]

We will store the numerical solution \(u\) and its time derivative
\(v\), \emph{at a given instant in time} on a three-dimensional
numerical grid. Since these variables are defined at each point on the
numerical grid, we call them \textbf{gridfunctions}.

We refer to the right-hand side of the equation
\(\partial_t \vec{f} = \mathbf{M}\ \vec{f}\) as the RHS. In this case,
we refer to the \(\mathbf{M}\ \vec{f}\) as the \textbf{scalar wave
RHSs}.

Armed with these definitions, the basic algorithm for solving the scalar
wave equation
\href{https://en.wikipedia.org/wiki/Initial_value_problem}{initial value
problem}, based on the Method of Lines (see section above) is outlined
below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Set up the numerical grid and free parameters
\item
  Allocate memory for gridfunctions, including temporary storage needed
  for the RK4 time integration.
\item
  Set gridfunction values to initial data.
\item
  Evolve the system forward in time using RK4 time integration. At each
  RK4 substep, do the following:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Evaluate scalar wave RHS expressions.
  \item
    Apply boundary conditions.
  \end{enumerate}
\end{enumerate}

In the following sections we will implement this algorithm to solve the
scalar wave equation in 3D \emph{by hand} using
\href{https://numpy.org/}{NumPy}, and to motivate the use of NRPy+.

    \hypertarget{step-3.a-numpy-implementation-set-up-the-numerical-grid-and-free-parameters-back-to-top}{%
\subsection{\texorpdfstring{Step 3.a: \texttt{NumPy} Implementation: Set
up the numerical grid and free parameters {[}Back to
\hyperref[toc]{top}{]}}{Step 3.a: NumPy Implementation: Set up the numerical grid and free parameters {[}Back to {]}}}\label{step-3.a-numpy-implementation-set-up-the-numerical-grid-and-free-parameters-back-to-top}}

\[\label{numgrid_freeparams}\]

We will solve the scalar wave equation on a uniform Cartesian grid with
\texttt{Nx} by \texttt{Ny} by \texttt{Nz} coordinate points in the
\(x\), \(y\), and \(z\) directions respectively. Since the grid is
uniform, we can describe the \(x\) coordinate of any gridpoint with a
single integer \(i\), and the same holds true for \(y\) and \(z\), for
which we will use integers \(j\) and \(k\). Thus we will label each
gridpoint \((x_i,y_j,z_k)\).

Let's choose a ``cell-centered'' grid, which will store the solution at
points \[
x_i \in \{..., -\frac{3}{2} \Delta x, -\frac{1}{2} \Delta x, +\frac{1}{2} \Delta x, +\frac{3}{2} \Delta x  ...\};
\] and we will allow for two additional ghost zones on the outer
boundary to account for the fourth-order finite differencing we will
implement to numerically compute \(\nabla^2 u\). Thus the expression for
computing \(x_i\) will be

\[
x_i = x_{\rm min} + \left( (i-\text{NGHOSTS}) + \frac{1}{2} \right) \Delta x,
\] where \(\Delta x\) is the spacing between gridpoints, and
\(x_{\rm min}\) denotes the minimum grid value in \(x\). We will solve
this equation on a cube centered on the origin with the
\texttt{domain\_size=10}, where \(x_{\rm min}=\) \texttt{-domain\_size},
\(y_{\rm min}=\) \texttt{-domain\_size}, \(z_{\rm min}=\)
\texttt{-domain\_size}, \(x_{\rm max}=\) \texttt{+domain\_size}, and so
forth. We'll also choose \texttt{Nx=Ny=Nz}, so that

\[
\Delta x = \Delta y = \Delta z = \frac{x_{\rm max}-x_{\rm min}}{\text{Nx}}.
\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}  \PY{c+c1}{\PYZsh{} NumPy: A numerical methods Python module}
\PY{n}{domain\PYZus{}size} \PY{o}{=} \PY{l+m+mf}{1.0}

\PY{n}{Nx} \PY{o}{=} \PY{n}{Ny} \PY{o}{=} \PY{n}{Nz} \PY{o}{=} \PY{l+m+mi}{24}
\PY{c+c1}{\PYZsh{} We add two ghostzones for the outer boundary; needed because our}
\PY{c+c1}{\PYZsh{}   finite\PYZhy{}differencing stencils are two gridpoints wide.}
\PY{n}{NGHOSTS} \PY{o}{=} \PY{l+m+mi}{2}

\PY{n}{xx} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}
\PY{n}{yy} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}
\PY{n}{zz} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}

\PY{n}{xmin} \PY{o}{=} \PY{n}{ymin} \PY{o}{=} \PY{n}{zmin} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{n}{domain\PYZus{}size}
\PY{n}{xmax} \PY{o}{=} \PY{n}{ymax} \PY{o}{=} \PY{n}{zmax} \PY{o}{=} \PY{o}{+}\PY{n}{domain\PYZus{}size}

\PY{n}{dx} \PY{o}{=} \PY{p}{(}\PY{n}{xmax} \PY{o}{\PYZhy{}} \PY{n}{xmin}\PY{p}{)} \PY{o}{/} \PY{n}{Nx}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{Nx} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
    \PY{n}{xx}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{n}{xmin} \PY{o}{+} \PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{NGHOSTS} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{p}{)} \PY{o}{*} \PY{n}{dx}
\PY{n}{dy} \PY{o}{=} \PY{p}{(}\PY{n}{ymax} \PY{o}{\PYZhy{}} \PY{n}{ymin}\PY{p}{)} \PY{o}{/} \PY{n}{Ny}
\PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{Ny} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
    \PY{n}{yy}\PY{p}{[}\PY{n}{j}\PY{p}{]} \PY{o}{=} \PY{n}{ymin} \PY{o}{+} \PY{p}{(}\PY{n}{j} \PY{o}{\PYZhy{}} \PY{n}{NGHOSTS} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{p}{)} \PY{o}{*} \PY{n}{dy}
\PY{n}{dz} \PY{o}{=} \PY{p}{(}\PY{n}{zmax} \PY{o}{\PYZhy{}} \PY{n}{zmin}\PY{p}{)} \PY{o}{/} \PY{n}{Nz}
\PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{Nz} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
    \PY{n}{zz}\PY{p}{[}\PY{n}{k}\PY{p}{]} \PY{o}{=} \PY{n}{zmin} \PY{o}{+} \PY{p}{(}\PY{n}{k} \PY{o}{\PYZhy{}} \PY{n}{NGHOSTS} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{p}{)} \PY{o}{*} \PY{n}{dz}
\end{Verbatim}
\end{tcolorbox}

    Next we set the free parameters for the scalar wave solution:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Set free parameters}
\PY{n}{freeparam\PYZus{}c}     \PY{o}{=} \PY{l+m+mf}{1.0}  \PY{c+c1}{\PYZsh{} wave speed}
\PY{n}{freeparam\PYZus{}sigma} \PY{o}{=} \PY{l+m+mf}{3.0}  \PY{c+c1}{\PYZsh{} width of Gaussian}
\PY{n}{freeparam\PYZus{}u\PYZus{}offset}\PY{o}{=}\PY{l+m+mf}{1.0}  \PY{c+c1}{\PYZsh{} offset of solution}
\end{Verbatim}
\end{tcolorbox}

    Then we set the timestep, which is governed by the
\href{https://en.wikipedia.org/wiki/Courant\%E2\%80\%93Friedrichs\%E2\%80\%93Lewy_condition}{CFL
condition}, and the final time \texttt{t\_final}, relative to the chosen
start time \(t_0\) (usually \(t_0=0\)), so that the points closest to
origin aren't affected by the approximate boundary condition:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{dt} \PY{o}{=} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{n+nb}{min}\PY{p}{(}\PY{n}{dx}\PY{p}{,}\PY{n+nb}{min}\PY{p}{(}\PY{n}{dy}\PY{p}{,}\PY{n}{dz}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{n}{freeparam\PYZus{}c}
\PY{n}{t\PYZus{}final} \PY{o}{=} \PY{n}{domain\PYZus{}size}\PY{o}{*}\PY{l+m+mf}{0.5}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3.b-numpy-implementation-set-up-the-initial-data-back-to-top}{%
\subsection{\texorpdfstring{Step 3.b: \texttt{NumPy} Implementation: Set
up the initial data {[}Back to
\hyperref[toc]{top}{]}}{Step 3.b: NumPy Implementation: Set up the initial data {[}Back to {]}}}\label{step-3.b-numpy-implementation-set-up-the-initial-data-back-to-top}}

\[\label{numpy_id}\]

Now we'll set up \texttt{exact\_solution\_all\_points(time,\ u,\ v)},
which numerically evaluates the solution for \(u\) and \(v\) at all
gridpoints at a given numerical time \texttt{time}.

Recall the exact solution is given by \begin{align}
u(r,t) &= u_{\rm out}(r,t) + u_{\rm in}(r,t) + 1,\ \ \text{where}\\
u_{\rm out}(r,t) &=\frac{r-ct}{r} \exp\left[\frac{-(r-ct)^2}{2 \sigma^2}\right] \\
u_{\rm in}(r,t) &=\frac{r+ct}{r} \exp\left[\frac{-(r+ct)^2}{2 \sigma^2}\right].
\end{align}

\emph{Exercise for students: Prove that at \(t=0\),
\(v=\partial_t u \equiv 0\).}

The problem is, SymPy expressions need to be converted to NumPy
expressions; otherwise using functions like \texttt{sp.N()} will be
\emph{incredibly slow}. So we attempt to fix this by some simple string
manipulations, some for \(v\) were done by hand using the below Python
function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{opt\PYZus{}string\PYZus{}replace}\PY{p}{(}\PY{n+nb}{input}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n+nb}{input}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sqrt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{np.sqrt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{exp}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{np.exp}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PYZbs{}
      \PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{x**2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{x\PYZus{}i*x\PYZus{}i}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y**2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y\PYZus{}j*y\PYZus{}j}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{z**2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{z\PYZus{}k*z\PYZus{}k}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PYZbs{}
      \PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{c*t}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{freeparam\PYZus{}c*time}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{sigma}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{freeparam\PYZus{}sigma}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{opt\PYZus{}string\PYZus{}replace}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{u\PYZus{}exact}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{opt\PYZus{}string\PYZus{}replace}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{v\PYZus{}exact}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
u\_offset + (-freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))*np.exp(-(-freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/np.sqrt(x\_i*x\_i + y\_j*y\_j + z\_k*z\_k) +
(freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))*np.exp(-(freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/np.sqrt(x\_i*x\_i + y\_j*y\_j + z\_k*z\_k)
c*np.exp(-(freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/np.sqrt(x\_i*x\_i + y\_j*y\_j + z\_k*z\_k) -
c*np.exp(-(-freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/np.sqrt(x\_i*x\_i + y\_j*y\_j + z\_k*z\_k) +
c*(-freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2*np.exp(-(-freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/(freeparam\_sigma**2*np.sqrt(x\_i*x\_i +
y\_j*y\_j + z\_k*z\_k)) - c*(freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2*np.exp(-(freeparam\_c*time + np.sqrt(x\_i*x\_i + y\_j*y\_j +
z\_k*z\_k))**2/(2*freeparam\_sigma**2))/(freeparam\_sigma**2*np.sqrt(x\_i*x\_i +
y\_j*y\_j + z\_k*z\_k))
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{exact\PYZus{}solution\PYZus{}single\PYZus{}pt\PYZus{}u}\PY{p}{(}\PY{n}{time}\PY{p}{,} \PY{n}{x\PYZus{}i}\PY{p}{,}\PY{n}{y\PYZus{}j}\PY{p}{,}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Kludge: The following expressions were pasted from above:}
                \PY{k}{return} \PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)} \PY{o}{+} \PY{n}{freeparam\PYZus{}u\PYZus{}offset}
\PY{k}{def} \PY{n+nf}{exact\PYZus{}solution\PYZus{}single\PYZus{}pt\PYZus{}v}\PY{p}{(}\PY{n}{time}\PY{p}{,} \PY{n}{x\PYZus{}i}\PY{p}{,}\PY{n}{y\PYZus{}j}\PY{p}{,}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Kludge: The following expressions were pasted from above, and edited slightly by hand}
                \PY{c+c1}{\PYZsh{}         to convert the symbol c to the numerical value for c, freeparam\PYZus{}c}
                \PY{k}{return} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)} \PY{o}{+} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{p}{(}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{n}{time} \PY{o}{+} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{freeparam\PYZus{}sigma}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{x\PYZus{}i}\PY{o}{*}\PY{n}{x\PYZus{}i} \PY{o}{+} \PY{n}{y\PYZus{}j}\PY{o}{*}\PY{n}{y\PYZus{}j} \PY{o}{+} \PY{n}{z\PYZus{}k}\PY{o}{*}\PY{n}{z\PYZus{}k}\PY{p}{)}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{exact\PYZus{}solution\PYZus{}all\PYZus{}points}\PY{p}{(}\PY{n}{time}\PY{p}{,} \PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
        \PY{n}{z\PYZus{}k} \PY{o}{=} \PY{n}{zz}\PY{p}{[}\PY{n}{k}\PY{p}{]}
        \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
            \PY{n}{y\PYZus{}j} \PY{o}{=} \PY{n}{yy}\PY{p}{[}\PY{n}{j}\PY{p}{]}
            \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
                \PY{n}{x\PYZus{}i} \PY{o}{=} \PY{n}{xx}\PY{p}{[}\PY{n}{i}\PY{p}{]}
                \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n}{exact\PYZus{}solution\PYZus{}single\PYZus{}pt\PYZus{}u}\PY{p}{(}\PY{n}{time}\PY{p}{,} \PY{n}{x\PYZus{}i}\PY{p}{,}\PY{n}{y\PYZus{}j}\PY{p}{,}\PY{n}{z\PYZus{}k}\PY{p}{)}
                \PY{n}{v}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n}{exact\PYZus{}solution\PYZus{}single\PYZus{}pt\PYZus{}v}\PY{p}{(}\PY{n}{time}\PY{p}{,} \PY{n}{x\PYZus{}i}\PY{p}{,}\PY{n}{y\PYZus{}j}\PY{p}{,}\PY{n}{z\PYZus{}k}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    To store the solution \(u\) and \(v\) at all gridpoints on our numerical
grid cube requires

\texttt{2*Nx*Ny*Nz*double}

bytes of memory, where \texttt{double} is the amount of memory storage
(in bytes) needed to store one
\href{https://en.wikipedia.org/wiki/Double-precision_floating-point_format}{double-precision
number} (this is 8, by the way).

    \hypertarget{step-3.c-numpy-implementation-allocate-memory-for-the-gridfunctions-storing-u-and-v-and-define-the-indexing-macro-function-back-to-top}{%
\subsection{\texorpdfstring{Step 3.c: \texttt{NumPy} Implementation:
Allocate memory for the gridfunctions storing \(u\) and \(v\), and
define the indexing macro function {[}Back to
\hyperref[toc]{top}{]}}{Step 3.c: NumPy Implementation: Allocate memory for the gridfunctions storing u and v, and define the indexing macro function {[}Back to {]}}}\label{step-3.c-numpy-implementation-allocate-memory-for-the-gridfunctions-storing-u-and-v-and-define-the-indexing-macro-function-back-to-top}}

\[\label{numpy_gfs}\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Allocate memory for gridfunctions. We need ghostzones}
\PY{n}{u} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    As is done in the Einstein Toolkit and native NRPy+ codes, instead of
declaring multi-dimensional arrays (e.g., a 3D array), we will instead
declare \(u\) and \(v\) as \emph{one-dimensional} arrays
\texttt{u{[}ijk{]}} and \texttt{v{[}ijk{]}}, each with
\texttt{(Nx+2*NGHOSTS)*(Ny+2*NGHOSTS)*(Nz+2*NGHOSTS)} gridpoints. To
access data an arbitrary point \((x_i,y_j,z_k)\), we need only call a
simple function to find the correct index \texttt{ijk} given the grid
indices \texttt{i}, \texttt{j}, and \texttt{k}, which label the point
\((x_i,y_j,z_k)\):

\[
\verb|
(i,j,k) = i + (Nx+2*NGHOSTS)*j + (Nx+2*NGHOSTS)*(Ny+2*NGHOSTS)*k = i + (Nx+2*NGHOSTS)*(j + (Ny+2*NGHOSTS)*k)|
\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Define the indexing macro function}
\PY{k}{def} \PY{n+nf}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{i} \PY{o}{+} \PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{j} \PY{o}{+} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{o}{*}\PY{n}{k}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3.d-numpy-implementation-define-the-right-hand-sides-of-the-pdes-back-to-top}{%
\subsection{\texorpdfstring{Step 3.d: \texttt{NumPy} Implementation:
Define the right-hand sides of the PDEs {[}Back to
\hyperref[toc]{top}{]}}{Step 3.d: NumPy Implementation: Define the right-hand sides of the PDEs {[}Back to {]}}}\label{step-3.d-numpy-implementation-define-the-right-hand-sides-of-the-pdes-back-to-top}}

\[\label{numpy_rhss}\]

Next we define the right-hand sides of the \(u\) and \(v\) equations:
\begin{align}
\partial_t u &= v \\
\partial_t v &= c^2 \nabla^2 u.
\end{align}

Again we'll approximate the \(\nabla^2 u\) using fourth-order
\href{https://en.wikipedia.org/wiki/Finite_difference}{finite-difference
derivatives} (also see
\href{Tutorial-Finite_Difference_Derivatives.ipynb}{the NRPy+ tutorial
on how to compute these expressions automatically or by hand using
simple matrix methods}).

Here we'll just use the
\href{https://en.wikipedia.org/wiki/Finite_difference_coefficient}{Wikipedia
article on finite-difference coefficients} to construct the expressions
for

\[
(\nabla u)_{i,j,k} = (\partial_x^2 u)_{i,j,k} + (\partial_y^2 u)_{i,j,k} + (\partial_z^2 u)_{i,j,k}
\] by hand:

The fourth-order finite difference stencil for
\((\partial_x^2 u)_{i,j,k}\) is written \begin{align}
(\partial_x^2 u)_{i,j,k} &= \left[-\frac{1}{12} u_{i-2,j,k} + \frac{4}{3} u_{i-1,j,k} - \frac{5}{2} u_{i,j,k} + \frac{4}{3} u_{i+1,j,k} - \frac{1}{12} u_{i+2,j,k}\right]\frac{1}{(\Delta x)^2} \\
&= \left[-\frac{1}{12} \left(u_{i-2,j,k} + u_{i+2,j,k}\right) + \frac{4}{3} \left(u_{i-1,j,k}+u_{i+1,j,k}\right) - \frac{5}{2} u_{i,j,k}\right]\frac{1}{(\Delta x)^2},
\end{align} and the expressions can be written for
\((\partial_y^2 u)_{i,j,k}\) and \((\partial_z^2 u)_{i,j,k}\) can be
immediately written based on this pattern:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{eval\PYZus{}rhs\PYZus{}all\PYZus{}interior\PYZus{}points}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{,} \PY{n}{u\PYZus{}rhs}\PY{p}{,} \PY{n}{v\PYZus{}rhs}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Notice that if we looped from e.g., k=0, then u[IDX3D(i,j,k\PYZhy{}2)] would be OUT OF BOUNDS.}
    \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{Nz}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}  \PY{c+c1}{\PYZsh{} Recall the valid range of k is 0 to Nz+2*NGHOSTS, ...}
        \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{Ny}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}  \PY{c+c1}{\PYZsh{} ... similarly for j and i}
            \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{Nx}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
                \PY{n}{u\PYZus{}rhs}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n}{v}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}
                \PY{c+c1}{\PYZsh{} First the x\PYZhy{}component of nabla}
                \PY{n}{v\PYZus{}rhs}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.}\PY{o}{/}\PY{l+m+mf}{12.} \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{+}\PY{l+m+mf}{4.}\PY{o}{/}\PY{l+m+mf}{3.}  \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{\PYZhy{}}\PY{l+m+mf}{5.}\PY{o}{/}\PY{l+m+mf}{2.}  \PY{o}{*} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{dx}\PY{o}{*}\PY{n}{dx}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} Then the y\PYZhy{}component of nabla}
                \PY{n}{v\PYZus{}rhs}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{o}{+}\PY{o}{=} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.}\PY{o}{/}\PY{l+m+mf}{12.} \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{o}{+}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{+}\PY{l+m+mf}{4.}\PY{o}{/}\PY{l+m+mf}{3.}  \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{\PYZhy{}}\PY{l+m+mf}{5.}\PY{o}{/}\PY{l+m+mf}{2.}  \PY{o}{*} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{dy}\PY{o}{*}\PY{n}{dy}\PY{p}{)}
                \PY{c+c1}{\PYZsh{} and finally the y\PYZhy{}component of nabla}
                \PY{n}{v\PYZus{}rhs}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{o}{+}\PY{o}{=} \PY{n}{freeparam\PYZus{}c}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{*} \PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.}\PY{o}{/}\PY{l+m+mf}{12.} \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{o}{+}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{+}\PY{l+m+mf}{4.}\PY{o}{/}\PY{l+m+mf}{3.}  \PY{o}{*} \PY{p}{(}\PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]} \PY{o}{+} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
                                                        \PY{o}{\PYZhy{}}\PY{l+m+mf}{5.}\PY{o}{/}\PY{l+m+mf}{2.}  \PY{o}{*} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{n}{j}\PY{p}{,}\PY{n}{k}\PY{p}{)}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{dz}\PY{o}{*}\PY{n}{dz}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3.e-numpy-implementation-boundary-conditions-back-to-top}{%
\subsection{\texorpdfstring{Step 3.e: \texttt{NumPy} Implementation:
Boundary Conditions {[}Back to
\hyperref[toc]{top}{]}}{Step 3.e: NumPy Implementation: Boundary Conditions {[}Back to {]}}}\label{step-3.e-numpy-implementation-boundary-conditions-back-to-top}}

\[\label{numpy_bcs}\]

Notice that the above code does not fill the input gridfunctions \(u\)
and \(v\) in the ghostzones, which will be updated at each Runge-Kutta
substep (as outlined next). We will need to apply our spatial boundary
conditions to fill in these points. For simplicity let's choose
quadratic extrapolation boundary conditions.

For example, suppose we are on the lower boundary point in \(x\):
\(u_{1,j,k}\). Then this boundary condition will be written as the
quadratic
\href{https://en.wikipedia.org/wiki/Polynomial_interpolation}{polynomial
extrapolation} taking data from the interior: \[
u_{1,j,k} = 3 u_{2,j,k} - 3 u_{3,j,k} + u_{4,j,k}.
\]

Similarly for the upper boundary point in \(x\), the condition becomes:
\[
u_{\text{Nx}-2,j,k} = 3 u_{\text{Nx}-3,j,k} - 3 u_{\text{Nx}-4,j,k} + u_{\text{Nx}-5,j,k}.
\]

We'll apply this algorithm from the innermost boundary point outward,
using the approach of filling in the (green-colored) ghost zones as
illustrated here in 2 dimensions (\emph{courtesy Leo Werneck}).
Extension to 3 dimensions is straightforward.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{i0min}\PY{p}{,}\PY{n}{i0max}\PY{p}{,} \PY{n}{i1min}\PY{p}{,}\PY{n}{i1max}\PY{p}{,} \PY{n}{i2min}\PY{p}{,}\PY{n}{i2max}\PY{p}{,} \PY{n}{FACEX0}\PY{p}{,}\PY{n}{FACEX1}\PY{p}{,}\PY{n}{FACEX2}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i2} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{i2min}\PY{p}{,}\PY{n}{i2max}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{i1} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{i1min}\PY{p}{,}\PY{n}{i1max}\PY{p}{)}\PY{p}{:}
            \PY{k}{for} \PY{n}{i0} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{i0min}\PY{p}{,}\PY{n}{i0max}\PY{p}{)}\PY{p}{:}
                \PY{n}{gf}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i0}\PY{p}{,}\PY{n}{i1}\PY{p}{,}\PY{n}{i2}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{o}{+}\PY{l+m+mf}{3.0}\PY{o}{*}\PY{n}{gf}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i0}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{*}\PY{n}{FACEX0}\PY{p}{,}\PY{n}{i1}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{*}\PY{n}{FACEX1}\PY{p}{,}\PY{n}{i2}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{*}\PY{n}{FACEX2}\PY{p}{)}\PY{p}{]}
                                       \PY{o}{\PYZhy{}}\PY{l+m+mf}{3.0}\PY{o}{*}\PY{n}{gf}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i0}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{FACEX0}\PY{p}{,}\PY{n}{i1}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{FACEX1}\PY{p}{,}\PY{n}{i2}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{FACEX2}\PY{p}{)}\PY{p}{]}
                                       \PY{o}{+}\PY{l+m+mf}{1.0}\PY{o}{*}\PY{n}{gf}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i0}\PY{o}{+}\PY{l+m+mi}{3}\PY{o}{*}\PY{n}{FACEX0}\PY{p}{,}\PY{n}{i1}\PY{o}{+}\PY{l+m+mi}{3}\PY{o}{*}\PY{n}{FACEX1}\PY{p}{,}\PY{n}{i2}\PY{o}{+}\PY{l+m+mi}{3}\PY{o}{*}\PY{n}{FACEX2}\PY{p}{)}\PY{p}{]}\PY{p}{)}

\PY{n}{MAXFACE} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}  \PY{c+c1}{\PYZsh{} Interp stencil reaches in the negative direction on upper (max) face}
\PY{n}{NUL}     \PY{o}{=} \PY{o}{+}\PY{l+m+mi}{0}
\PY{n}{MINFACE} \PY{o}{=} \PY{o}{+}\PY{l+m+mi}{1}  \PY{c+c1}{\PYZsh{} Interp stencil reaches in the positive direction on lower (min) face}
\PY{k}{def} \PY{n+nf}{apply\PYZus{}extrapolation\PYZus{}bcs}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{gf} \PY{o+ow}{in} \PY{p}{[}\PY{n}{u}\PY{p}{,}\PY{n}{v}\PY{p}{]}\PY{p}{:}
        \PY{n}{imin} \PY{o}{=} \PY{p}{[}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{NGHOSTS}\PY{p}{]}
        \PY{n}{imax} \PY{o}{=} \PY{p}{[}\PY{n}{Nx}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{Ny}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{,} \PY{n}{Nz}\PY{o}{+}\PY{n}{NGHOSTS}\PY{p}{]}
        \PY{k}{for} \PY{n}{which\PYZus{}gz} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} After updating each face, adjust imin[] and imax[]}
            \PY{c+c1}{\PYZsh{}   to reflect the newly\PYZhy{}updated face extents.}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{MINFACE}\PY{p}{,}\PY{n}{NUL}\PY{p}{,}\PY{n}{NUL}\PY{p}{)}\PY{p}{;} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{o}{=}\PY{l+m+mi}{1}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{MAXFACE}\PY{p}{,}\PY{n}{NUL}\PY{p}{,}\PY{n}{NUL}\PY{p}{)}\PY{p}{;} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{NUL}\PY{p}{,}\PY{n}{MINFACE}\PY{p}{,}\PY{n}{NUL}\PY{p}{)}\PY{p}{;} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{o}{=}\PY{l+m+mi}{1}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{NUL}\PY{p}{,}\PY{n}{MAXFACE}\PY{p}{,}\PY{n}{NUL}\PY{p}{)}\PY{p}{;} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{NUL}\PY{p}{,}\PY{n}{NUL}\PY{p}{,}\PY{n}{MINFACE}\PY{p}{)}\PY{p}{;} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{o}{=}\PY{l+m+mi}{1}
            \PY{n}{bc\PYZus{}face\PYZus{}update}\PY{p}{(}\PY{n}{gf}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{imin}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{NUL}\PY{p}{,}\PY{n}{NUL}\PY{p}{,}\PY{n}{MAXFACE}\PY{p}{)}\PY{p}{;} \PY{n}{imax}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3.f-numpy-implementation-the-method-of-lines-back-to-top}{%
\subsection{\texorpdfstring{Step 3.f: \texttt{NumPy} Implementation: The
Method of Lines {[}Back to
\hyperref[toc]{top}{]}}{Step 3.f: NumPy Implementation: The Method of Lines {[}Back to {]}}}\label{step-3.f-numpy-implementation-the-method-of-lines-back-to-top}}

\[\label{numpy_mol}\]

Next we'll set up the Method of Lines (MoL) routine for Runge-Kutta
fourth order (RK4), which takes the solution at a given iteration in
time \(n\), and enables us to advance the solution forward to iteration
\(n+1\), as outlined above:

\begin{align}
k_{1,u} &= f_u(u_n,v_n) = f_u(v_n) = v_n, \\
k_{1,v} &= f_v(u_n,v_n) = f_v(u_n) = c^2\nabla^2 u_n, \\
k_{2,u} &= f_u\left(v_n + \frac{1}{2}\Delta tk_{1,v}\right) = v_n + \frac{1}{2}\Delta tk_{1,v}\\
k_{2,v} &= f_v\left(u_n + \frac{1}{2}\Delta tk_{1,u}\right) = c^2\nabla^2 \left(u_n + \frac{1}{2}\Delta tk_{1,u}\right), \\
k_{3,u} &= f_u\left(v_n + \frac{1}{2}\Delta tk_{2,v}\right) = v_n + \frac{1}{2}\Delta tk_{2,v}\\
k_{3,v} &= f_v\left(u_n + \frac{1}{2}\Delta tk_{2,u}\right) = c^2\nabla^2 \left(u_n + \frac{1}{2}\Delta tk_{2,u}\right), \\
k_{4,u} &= f_u(v_n + \Delta tk_{3,v}) = v_n + \Delta tk_{3,v}\\
k_{4,v} &= f_v(u_n + \Delta tk_{3,u}) = c^2\nabla^2 \left(u_n + \Delta tk_{3,u}\right), \\
u_{n+1} &= u_n + \frac{1}{6}\Delta t(k_{1,u} + 2k_{2,u} + 2k_{3,u} + k_{4,u}) + \mathcal{O}\big((\Delta t)^5\big)\\
v_{n+1} &= v_n + \frac{1}{6}\Delta t(k_{1,v} + 2k_{2,v} + 2k_{3,v} + k_{4,v}) + \mathcal{O}\big((\Delta t)^5\big).
\end{align}

We will store \(k_1\) through \(k_4\) as additional gridfunctions, one
each for \(u\) and \(v\), and another gridfunction for \(u\) and \(v\)
(\texttt{u\_tmp} and \texttt{v\_tmp}, respectively) for the input into
\(f_u()\) and \(f_v()\) functions:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{u\PYZus{}k1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v\PYZus{}k1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{u\PYZus{}k2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v\PYZus{}k2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{u\PYZus{}k3} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v\PYZus{}k3} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{u\PYZus{}k4} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v\PYZus{}k4} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{u\PYZus{}tmp} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\PY{n}{v\PYZus{}tmp} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \ldots{} then implement a single timestep by calling the
\texttt{eval\_rhs\_all\_interior\_points()} function above with
appropriate inputs. Recall that the RK4 algorithm is given by
\begin{align}
k_1 &= f(y_n, t_n), \\
k_2 &= f(y_n + \frac{1}{2}\Delta tk_1, t_n + \frac{\Delta t}{2}), \\
k_3 &= f(y_n + \frac{1}{2}\Delta tk_2, t_n + \frac{\Delta t}{2}), \\
k_4 &= f(y_n + \Delta tk_3, t_n + \Delta t), \\
y_{n+1} &= y_n + \frac{1}{6}\Delta t(k_1 + 2k_2 + 2k_3 + k_4) + \mathcal{O}\big((\Delta t)^5\big).
\end{align}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{one\PYZus{}RK\PYZus{}step}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Compute k\PYZus{}1}
    \PY{n}{eval\PYZus{}rhs\PYZus{}all\PYZus{}interior\PYZus{}points}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{,} \PY{n}{u\PYZus{}k1}\PY{p}{,} \PY{n}{v\PYZus{}k1}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Compute inputs into k\PYZus{}2}
    \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{u\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{u}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{n}{u\PYZus{}k1}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
        \PY{n}{v\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{v}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{n}{v\PYZus{}k1}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} Apply BCs to u\PYZus{}tmp and v\PYZus{}tmp:}
    \PY{n}{apply\PYZus{}extrapolation\PYZus{}bcs}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Compute k\PYZus{}2}
    \PY{n}{eval\PYZus{}rhs\PYZus{}all\PYZus{}interior\PYZus{}points}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{,} \PY{n}{u\PYZus{}k2}\PY{p}{,} \PY{n}{v\PYZus{}k2}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Compute inputs into k\PYZus{}3}
    \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{u\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{u}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{n}{u\PYZus{}k2}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
        \PY{n}{v\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{v}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{n}{v\PYZus{}k2}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} Apply BCs to u\PYZus{}tmp and v\PYZus{}tmp:}
    \PY{n}{apply\PYZus{}extrapolation\PYZus{}bcs}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Compute k\PYZus{}3}
    \PY{n}{eval\PYZus{}rhs\PYZus{}all\PYZus{}interior\PYZus{}points}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{,} \PY{n}{u\PYZus{}k3}\PY{p}{,} \PY{n}{v\PYZus{}k3}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Compute inputs into k\PYZus{}4}
    \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{u\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{u}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{n}{dt}\PY{o}{*}\PY{n}{u\PYZus{}k3}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
        \PY{n}{v\PYZus{}tmp}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{v}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{n}{dt}\PY{o}{*}\PY{n}{v\PYZus{}k3}\PY{p}{[}\PY{n}{idx}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} Apply BCs to u\PYZus{}tmp and v\PYZus{}tmp:}
    \PY{n}{apply\PYZus{}extrapolation\PYZus{}bcs}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Compute k\PYZus{}4}
    \PY{n}{eval\PYZus{}rhs\PYZus{}all\PYZus{}interior\PYZus{}points}\PY{p}{(}\PY{n}{u\PYZus{}tmp}\PY{p}{,} \PY{n}{v\PYZus{}tmp}\PY{p}{,} \PY{n}{u\PYZus{}k4}\PY{p}{,} \PY{n}{v\PYZus{}k4}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Finally compute y\PYZus{}\PYZob{}n+1\PYZcb{}}
    \PY{k}{for} \PY{n}{idx} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)} \PY{o}{*} \PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{u}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{u}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{p}{(}\PY{l+m+mf}{1.0}\PY{o}{/}\PY{l+m+mf}{6.0}\PY{p}{)}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{p}{(}\PY{n}{u\PYZus{}k1}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{u\PYZus{}k2}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{u\PYZus{}k3}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{n}{u\PYZus{}k4}\PY{p}{[}\PY{n}{idx}\PY{p}{]}\PY{p}{)}
        \PY{n}{v}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{=} \PY{n}{v}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{p}{(}\PY{l+m+mf}{1.0}\PY{o}{/}\PY{l+m+mf}{6.0}\PY{p}{)}\PY{o}{*}\PY{n}{dt}\PY{o}{*}\PY{p}{(}\PY{n}{v\PYZus{}k1}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{v\PYZus{}k2}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{2}\PY{o}{*}\PY{n}{v\PYZus{}k3}\PY{p}{[}\PY{n}{idx}\PY{p}{]} \PY{o}{+} \PY{n}{v\PYZus{}k4}\PY{p}{[}\PY{n}{idx}\PY{p}{]}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} ... and apply BCs to the updated u and v:}
    \PY{n}{apply\PYZus{}extrapolation\PYZus{}bcs}\PY{p}{(}\PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3.g-numpy-implementation-the-main-driver-function-back-to-top}{%
\subsection{\texorpdfstring{Step 3.g: \texttt{NumPy} Implementation: The
main driver function {[}Back to
\hyperref[toc]{top}{]}}{Step 3.g: NumPy Implementation: The main driver function {[}Back to {]}}}\label{step-3.g-numpy-implementation-the-main-driver-function-back-to-top}}

\[\label{numpy_driver}\]

Finally we'll write the main driver function, which as a diagnostic
outputs the relative error between numerical and exact solutions at the
closest point to the center of the numerical grid.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}

\PY{n}{initial\PYZus{}time} \PY{o}{=} \PY{l+m+mf}{0.0}

\PY{c+c1}{\PYZsh{} First set up the initial data:}
\PY{n}{exact\PYZus{}solution\PYZus{}all\PYZus{}points}\PY{p}{(}\PY{n}{initial\PYZus{}time}\PY{p}{,} \PY{n}{u}\PY{p}{,} \PY{n}{v}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Store the indices at the point closest to the origin}
\PY{n}{i\PYZus{}o} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{p}{(}\PY{n}{Nx}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{j\PYZus{}o} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{p}{(}\PY{n}{Ny}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{k\PYZus{}o} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{p}{(}\PY{n}{Nz}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{NGHOSTS}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsh{} Outputting data at (x,y,z) = (}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s2}{,}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s2}{,}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{xx}\PY{p}{[}\PY{n}{i\PYZus{}o}\PY{p}{]}\PY{p}{,}\PY{n}{yy}\PY{p}{[}\PY{n}{j\PYZus{}o}\PY{p}{]}\PY{p}{,}\PY{n}{zz}\PY{p}{[}\PY{n}{k\PYZus{}o}\PY{p}{]}\PY{p}{)}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{diagnostics}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Print the time and the value of the solution closest to the origin}
    \PY{n}{curr\PYZus{}time} \PY{o}{=} \PY{n}{initial\PYZus{}time} \PY{o}{+} \PY{n}{n}\PY{o}{*}\PY{n}{dt}
    \PY{n}{num}   \PY{o}{=} \PY{n}{u}\PY{p}{[}\PY{n}{IDX3D}\PY{p}{(}\PY{n}{i\PYZus{}o}\PY{p}{,} \PY{n}{j\PYZus{}o}\PY{p}{,} \PY{n}{k\PYZus{}o}\PY{p}{)}\PY{p}{]}
    \PY{n}{exact} \PY{o}{=} \PY{n}{exact\PYZus{}solution\PYZus{}single\PYZus{}pt\PYZus{}u}\PY{p}{(}\PY{n}{curr\PYZus{}time}\PY{p}{,} \PY{n}{xx}\PY{p}{[}\PY{n}{i\PYZus{}o}\PY{p}{]}\PY{p}{,}\PY{n}{yy}\PY{p}{[}\PY{n}{j\PYZus{}o}\PY{p}{]}\PY{p}{,}\PY{n}{zz}\PY{p}{[}\PY{n}{k\PYZus{}o}\PY{p}{]}\PY{p}{)}
    \PY{n}{log10relerror} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{log10}\PY{p}{(}\PY{n+nb}{max}\PY{p}{(}\PY{l+m+mf}{1e\PYZhy{}16}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{abs}\PY{p}{(}\PY{p}{(}\PY{n}{num}\PY{o}{\PYZhy{}}\PY{n}{exact}\PY{p}{)}\PY{o}{/}\PY{n}{exact}\PY{p}{)}\PY{p}{)}\PY{p}{)}
    \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZpc{}.12f}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZpc{}.12f}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{n}{curr\PYZus{}time}\PY{p}{,} \PY{n}{log10relerror}\PY{p}{,} \PY{n}{num}\PY{p}{,} \PY{n}{exact}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Output diagnostics at the initial time.}
\PY{n}{out\PYZus{}str} \PY{o}{=} \PY{n}{diagnostics}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Then integrate forward in time:}
\PY{n}{n\PYZus{}final} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{n}{t\PYZus{}final}\PY{o}{/}\PY{n}{dt} \PY{o}{+} \PY{l+m+mf}{0.5}\PY{p}{)}  \PY{c+c1}{\PYZsh{} add 0.5 to correct for rounding.}
\PY{n}{n\PYZus{}out\PYZus{}every} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{n}{Nx}\PY{o}{/}\PY{l+m+mf}{24.}\PY{p}{)}  \PY{c+c1}{\PYZsh{} Output every timestep for Nx=24; every other timestep for Nx=48; etc}
\PY{k+kn}{import} \PY{n+nn}{time}  \PY{c+c1}{\PYZsh{} for live benchmarking \PYZam{} estimates}
\PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
\PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{n}{n\PYZus{}final}\PY{p}{)}\PY{p}{:}
    \PY{n}{ETA} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{N/A}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{if} \PY{n}{n} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{time\PYZus{}elapsed\PYZus{}in\PYZus{}seconds} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{start}
        \PY{n}{seconds\PYZus{}per\PYZus{}n} \PY{o}{=} \PY{n}{time\PYZus{}elapsed\PYZus{}in\PYZus{}seconds}\PY{o}{/}\PY{n}{n}
        \PY{n}{time\PYZus{}remaining\PYZus{}m\PYZus{}field} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{p}{(}\PY{n}{n\PYZus{}final} \PY{o}{\PYZhy{}} \PY{n}{n}\PY{p}{)}\PY{o}{*}\PY{n}{seconds\PYZus{}per\PYZus{}n}\PY{o}{/}\PY{l+m+mi}{60}\PY{p}{)}
        \PY{n}{time\PYZus{}remaining\PYZus{}s\PYZus{}field} \PY{o}{=} \PY{p}{(}\PY{n}{n\PYZus{}final} \PY{o}{\PYZhy{}} \PY{n}{n}\PY{p}{)}\PY{o}{*}\PY{n}{seconds\PYZus{}per\PYZus{}n} \PY{o}{\PYZhy{}} \PY{n}{time\PYZus{}remaining\PYZus{}m\PYZus{}field}\PY{o}{*}\PY{l+m+mi}{60}
        \PY{n}{ETA} \PY{o}{=} \PY{n+nb}{str}\PY{p}{(}\PY{n}{time\PYZus{}remaining\PYZus{}m\PYZus{}field}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{m}\PY{l+s+s2}{\PYZdq{}}\PY{o}{+} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n}{time\PYZus{}remaining\PYZus{}s\PYZus{}field} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{s}\PY{l+s+s2}{\PYZdq{}}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsh{} Integrating forward in time, to time }\PY{l+s+si}{\PYZpc{}.3f}\PY{l+s+s2}{ . ETA: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s2}{ seconds}\PY{l+s+s2}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{p}{(}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{*}\PY{n}{dt}\PY{p}{,} \PY{n}{ETA}\PY{p}{)}\PY{p}{)}
    \PY{n}{one\PYZus{}RK\PYZus{}step}\PY{p}{(}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} After the RK step we are at iteration n+1}
    \PY{k}{if}\PY{p}{(}\PY{p}{(}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n}{n\PYZus{}out\PYZus{}every} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{:}
        \PY{n}{out\PYZus{}str} \PY{o}{+}\PY{o}{=} \PY{n}{diagnostics}\PY{p}{(}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}

\PY{n}{experiment\PYZus{}filename} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output\PYZus{}experiment\PYZus{}resolution\PYZus{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{n+nb}{str}\PY{p}{(}\PY{n}{Nx}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZus{}cubed.txt}\PY{l+s+s2}{\PYZdq{}}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsh{} Results, output to file }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n}{experiment\PYZus{}filename}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{out\PYZus{}str}\PY{p}{)}
\PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{experiment\PYZus{}filename}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
    \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{out\PYZus{}str}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
\# Outputting data at (x,y,z) = (0.04,0.04,0.04)
\# Integrating forward in time, to time 0.042 . ETA: N/A seconds
\# Integrating forward in time, to time 0.083 . ETA: 0m6.38s seconds
\# Integrating forward in time, to time 0.125 . ETA: 0m5.91s seconds
\# Integrating forward in time, to time 0.167 . ETA: 0m5.26s seconds
\# Integrating forward in time, to time 0.208 . ETA: 0m4.65s seconds
\# Integrating forward in time, to time 0.250 . ETA: 0m4.03s seconds
\# Integrating forward in time, to time 0.292 . ETA: 0m3.44s seconds
\# Integrating forward in time, to time 0.333 . ETA: 0m2.86s seconds
\# Integrating forward in time, to time 0.375 . ETA: 0m2.28s seconds
\# Integrating forward in time, to time 0.417 . ETA: 0m1.70s seconds
\# Integrating forward in time, to time 0.458 . ETA: 0m1.13s seconds
\# Integrating forward in time, to time 0.500 . ETA: 0m0.57s seconds
\# Results, output to file output\_experiment\_resolution\_24\_cubed.txt
0.00 -16.00 2.999421380013 2.999421380013
0.04 -10.70 2.998843001874 2.998843001814
0.08 -10.06 2.997108425138 2.997108424880
0.12 -9.70 2.994219322036 2.994219321440
0.17 -9.45 2.990178477110 2.990178476038
0.21 -9.25 2.984989783456 2.984989781772
0.25 -9.09 2.978658237475 2.978658235046
0.29 -8.95 2.971189932138 2.971189928832
0.33 -8.84 2.962592048775 2.962592044465
0.38 -8.73 2.952872847425 2.952872841973
0.42 -8.64 2.942041655765 2.942041648971
0.46 -8.54 2.930108856521 2.930108848127
0.50 -8.48 2.917085872939 2.917085863230

CPU times: user 7.44 s, sys: 2.25 ms, total: 7.45 s
Wall time: 7.44 s
    \end{Verbatim}

    \hypertarget{step-4-argh-the-code-is-slow-why-use-nrpy-instead-back-to-top}{%
\section{\texorpdfstring{Step 4: Argh, the code is SLOW! Why use NRPy+
instead? {[}Back to
\hyperref[toc]{top}{]}}{Step 4: Argh, the code is SLOW! Why use NRPy+ instead? {[}Back to {]}}}\label{step-4-argh-the-code-is-slow-why-use-nrpy-instead-back-to-top}}

\[\label{too_slow}\]

By default the above code outputs data on the \texttt{Nx=Ny=Nz=24} =
\(24^3\) numerical grid, and it takes around 16 seconds to complete (on
mybinder).

If we were to double the resolution to \(48^3\) (keeping the domain size
fixed), the number of gridpoints we need to update increases by a factor
of 8, and the timestep reduces by a factor of 2; hence the total cost is
about 16x higher. Thus it will take roughly 16 seconds, times 16, or
roughly 4 minutes to complete a \(48^3\) resolution simulation on the
same CPU. Similarly, it should take a bit over an hour to complete a
simulation with \(96^3\) resolution!

One reason we wish to use \texttt{NRPy+} to convert human-friendly
Python expressions (written in \texttt{SymPy}) to highly optimized C
code is the speed. As we'll see, a C code implementing exactly the same
algorithm for solving the scalar wave equation can generate results
roughly 10,000x faster!

Given how slowly the above Python code solves the scalar wave equation,
solving Einstein's equations of general relativity in 3 dimensions with
a Python code would be a futile effort. However, speed of execution
isn't the only reason to use NRPy+. Here are some more reasons: 1. NRPy+
contains a rigid syntax for SymPy symbols that 1. enables you to specify
derivatives (e.g., \(\partial_j u\)= \texttt{u\_dD{[}j{]}}) and output C
code at arbitrary finite differencing (FD) order 1.
\href{Tutorial-Finite_Difference_Derivatives.ipynb}{\textbf{tutorial on
FD derivatives}}; 1.
\href{Tutorial-How_NRPy_Computes_Finite_Difference_Coeffs.ipynb}{\textbf{tutorial
on computing FD coefficients}}; 1.
\href{Tutorial-Start_to_Finish-Finite_Difference_Playground.ipynb}{\textbf{sample
C code tutorial}} 1. allows for tensorial expressions to be input
unambiguously in Einstein-like notation (e.g., \(\gamma_{ij}=\)
\texttt{gammaDD{[}i{]}{[}j{]}}) 1.
\href{Tutorial-Indexed_Expressions.ipynb}{\textbf{tutorial on indexed
(e.g., tensorial) expressions}} 1. NRPy+ automatically implements 15
different RK-like timestepping methods for MoL 1.
\href{Tutorial-RK_Butcher_Table_Dictionary.ipynb}{\textbf{tutorial on
NRPy+ dictionary of RK methods}}; 1.
\href{Tutorial-RK_Butcher_Table_Validation.ipynb}{\textbf{tutorial
validating the NRPy+ RK dictionary}}; 1.
\href{Tutorial-Method_of_Lines-C_Code_Generation.ipynb}{\textbf{tutorial
on C code MoL implementation}} 1. NRPy+ supports two boundary condition
drivers (quadratic extrapolation and Sommerfeld), and more can be
supported 1.
\href{Tutorial-Start_to_Finish-Curvilinear_BCs.ipynb}{\textbf{tutorial
on general boundary condition driver}}; 1.
\href{Tutorial-SommerfeldBoundaryCondition.ipynb}{\textbf{Sommerfeld
tutorial}} 1. NRPy+ provides support for solving the scalar wave
equation stably in curvilinear coordinates, including Cartesian,
spherical-like, cylindrical-like, and prolate-spheroidal-like
coordinates 1. \href{Tutorial-ScalarWave.ipynb}{\textbf{tutorial on
Cartesian scalar wave equation in NRPy+}}; 1.
\href{Tutorial-Start_to_Finish-ScalarWave.ipynb}{\textbf{tutorial on C
code scalar wave implementation}}; 1.
\href{Tutorial-Reference_Metric.ipynb}{\textbf{tutorial on NRPy+
curvilinear coordinates (reference metric) support}}; 1.
\href{Tutorial-ScalarWaveCurvilinear.ipynb}{\textbf{tutorial on scalar
wave equation in curvilinear coordinates}} 1. Einstein Toolkit thorns 1.
\href{Tutorial-ETK_thorn-WaveToyNRPy.ipynb}{\textbf{tutorial on
\texttt{WaveToyNRPy}, for solving the scalar wave equation}} 1.
\href{Tutorial-ETK_thorn-IDScalarWaveNRPy.ipynb}{\textbf{tutorial on
\texttt{IDScalarWaveNRPy}, for setting up scalar wave initial data}} 1.
NRPy+ implements a covariant BSSN formulation that supports Cartesian,
spherical-like, and cylindrical-like coordinates, and its boundary
condition driver automatically sets up correct boundary conditions for
any tensor in any orthogonal coordinate system! 1.
\href{Tutorial-BSSN_formulation.ipynb}{\textbf{BSSN overview tutorial;
contains links to several other tutorials}} 1. Einstein Toolkit thorns
1. \href{Tutorial-BaikalETK.ipynb}{\textbf{tutorial on \texttt{Baikal}
\& \texttt{BaikalVacuum}, for solving Einstein's equations in Cartesian
coordinates}} 1. NRPy+ contains multiple initial data sets for
Einstein's equations of general relativity, and a means to quickly
validate they satisfy the Einstein constraint equations on numerical
grids 1.
\href{Tutorial-Start_to_Finish-BSSNCurvilinear-Setting_up_Exact_Initial_Data.ipynb}{\textbf{BSSN
initial data validation}}; 1.
\href{Tutorial-ADM_Initial_Data-StaticTrumpet.ipynb}{\textbf{static
trumpet initial data}}; 1.
\href{Tutorial-ADM_Initial_Data-UIUC_BlackHole.ipynb}{\textbf{``UIUC''
spinning black hole initial data}}; 1.
\href{Tutorial-ADM_Initial_Data-ShiftedKerrSchild.ipynb}{\textbf{shifted
Kerr-Schild initial data}}; 1.
\href{Tutorial-ADM_Initial_Data-Brill-Lindquist.ipynb}{\textbf{Brill-Lindquist
initial data}}; 1.
\href{Tutorial-FishboneMoncriefID.ipynb}{\textbf{Fishbone-Moncrief black
hole accretion disk initial data}}; 1.
\href{Tutorial-ADM_Initial_Data-TOV.ipynb}{\textbf{piecewise-polytrope
TOV initial data}} 1. NRPy+ contains multiple diagnostics for spacetime
evolutions 1.
\href{Tutorial-WeylScalarsInvariants-Cartesian.ipynb}{\textbf{computing
\(\psi_4\) in Cartesian coordinates}} 1.
\href{Tutorial-Psi4.ipynb}{\textbf{computing \(\psi_4\) in curvilinear
coordinates}} 1. \href{Tutorial-Psi4_tetrads.ipynb}{\textbf{\(\psi_4\)
tetrads in curvilinear coordinates}} 1. Einstein Toolkit thorn 1.
\href{Tutorial-ETK_thorn-Weyl_Scalars_and_Spacetime_Invariants.ipynb}{\textbf{\texttt{WeylScal4NRPy},
a \texttt{WeylScal4} clone written in NRPy+}}

    \hypertarget{step-5-error-analysis-code-validation-confirming-numerical-errors-converge-to-zero-at-the-expected-rate-back-to-top}{%
\section{\texorpdfstring{Step 5: Error analysis \& code validation:
Confirming numerical errors converge to zero at the expected rate
{[}Back to
\hyperref[toc]{top}{]}}{Step 5: Error analysis \& code validation: Confirming numerical errors converge to zero at the expected rate {[}Back to {]}}}\label{step-5-error-analysis-code-validation-confirming-numerical-errors-converge-to-zero-at-the-expected-rate-back-to-top}}

\[\label{error_analysis}\]

The above code is \emph{really slow}, so to bypass the long wait,
results at \(24^3\), \(48^3\), and \(96^3\) are \emph{precomputed} and
output to files in the next cell:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Pasted results, assuming u\PYZus{}offset=1 and Nx=Ny=Nz=24}
\PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output\PYZus{}resolution\PYZus{}24cubed.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
    \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{0.00 \PYZhy{}16.00 2.999421380013 2.999421380013}
\PY{l+s+s2}{0.04 \PYZhy{}10.70 2.998843001874 2.998843001814}
\PY{l+s+s2}{0.08 \PYZhy{}10.06 2.997108425138 2.997108424880}
\PY{l+s+s2}{0.12 \PYZhy{}9.70 2.994219322036 2.994219321440}
\PY{l+s+s2}{0.17 \PYZhy{}9.45 2.990178477110 2.990178476038}
\PY{l+s+s2}{0.21 \PYZhy{}9.25 2.984989783456 2.984989781772}
\PY{l+s+s2}{0.25 \PYZhy{}9.09 2.978658237475 2.978658235046}
\PY{l+s+s2}{0.29 \PYZhy{}8.95 2.971189932138 2.971189928832}
\PY{l+s+s2}{0.33 \PYZhy{}8.84 2.962592048775 2.962592044465}
\PY{l+s+s2}{0.38 \PYZhy{}8.73 2.952872847425 2.952872841973}
\PY{l+s+s2}{0.42 \PYZhy{}8.64 2.942041655765 2.942041648971}
\PY{l+s+s2}{0.46 \PYZhy{}8.54 2.930108856521 2.930108848127}
\PY{l+s+s2}{0.50 \PYZhy{}8.48 2.917085872939 2.917085863230}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Pasted results, assuming u\PYZus{}offset=1 and Nx=Ny=Nz=48 \PYZlt{}\PYZhy{} required 2 minutes on fast computer}
\PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output\PYZus{}resolution\PYZus{}48cubed.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
    \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{0.00 \PYZhy{}16.00 2.999855329307 2.999855329307}
\PY{l+s+s2}{0.04 \PYZhy{}11.87 2.999276741878 2.999276741874}
\PY{l+s+s2}{0.08 \PYZhy{}11.25 2.997541537534 2.997541537518}
\PY{l+s+s2}{0.12 \PYZhy{}10.89 2.994651389354 2.994651389316}
\PY{l+s+s2}{0.17 \PYZhy{}10.64 2.990609083291 2.990609083222}
\PY{l+s+s2}{0.21 \PYZhy{}10.45 2.985418514411 2.985418514305}
\PY{l+s+s2}{0.25 \PYZhy{}10.29 2.979084681648 2.979084681494}
\PY{l+s+s2}{0.29 \PYZhy{}10.15 2.971613681053 2.971613680844}
\PY{l+s+s2}{0.33 \PYZhy{}10.04 2.963012697588 2.963012697316}
\PY{l+s+s2}{0.38 \PYZhy{}9.93 2.953289995451 2.953289995108}
\PY{l+s+s2}{0.42 \PYZhy{}9.84 2.942454906957 2.942454906535}
\PY{l+s+s2}{0.46 \PYZhy{}9.76 2.930517820003 2.930517819496}
\PY{l+s+s2}{0.50 \PYZhy{}9.69 2.917490164124 2.917490163524}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Pasted results, assuming u\PYZus{}offset=1 and Nx=Ny=Nz=96 \PYZlt{}\PYZhy{} required}
\PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output\PYZus{}resolution\PYZus{}96cubed.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
    \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{0.00 \PYZhy{}16.00 2.999963831346 2.999963831346}
\PY{l+s+s2}{0.04 \PYZhy{}13.06 2.999385191594 2.999385191594}
\PY{l+s+s2}{0.08 \PYZhy{}12.45 2.997649830354 2.997649830353}
\PY{l+s+s2}{0.12 \PYZhy{}12.09 2.994759420914 2.994759420911}
\PY{l+s+s2}{0.17 \PYZhy{}11.84 2.990716749579 2.990716749575}
\PY{l+s+s2}{0.21 \PYZhy{}11.65 2.985525711912 2.985525711906}
\PY{l+s+s2}{0.25 \PYZhy{}11.49 2.979191307475 2.979191307466}
\PY{l+s+s2}{0.29 \PYZhy{}11.36 2.971719633092 2.971719633079}
\PY{l+s+s2}{0.33 \PYZhy{}11.24 2.963117874631 2.963117874614}
\PY{l+s+s2}{0.38 \PYZhy{}11.14 2.953394297333 2.953394297311}
\PY{l+s+s2}{0.42 \PYZhy{}11.05 2.942558234689 2.942558234663}
\PY{l+s+s2}{0.46 \PYZhy{}10.97 2.930620075904 2.930620075872}
\PY{l+s+s2}{0.50 \PYZhy{}10.89 2.917591251949 2.917591251911}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    We say that our scheme is fourth-order-accurate in the truncation error,
so the numerical solution at a given point \((t,x,y,z)\),
\(u_{\rm num}\), should satisfy the equation

\[u_{\rm num} = u_{\rm exact} + \mathcal{O}(\Delta x^4) + \mathcal{O}(\Delta t^4),\]

where \(u_{\rm exact}\) is the exact solution, and
\(\mathcal{O}(\Delta x^4)\) and \(\mathcal{O}(\Delta t^4)\) are terms
proportional to \(\Delta x^4\) and \(\Delta t^4\), respectively. However
note that the
\href{https://en.wikipedia.org/wiki/Courant\%E2\%80\%93Friedrichs\%E2\%80\%93Lewy_condition}{CFL
condition} for this PDE requires that \(\Delta x \propto \Delta t\), so
we can simplify the above expression to

\[u_{\rm num} = u_{\rm exact} + \mathcal{O}(\Delta x^4).\]

Therefore, the
\href{https://en.wikipedia.org/wiki/Approximation_error}{relative error}
between the numerical and the exact solution should be given to good
approximation by

\begin{align}
E_{\rm Rel} &= \left| \frac{u_{\rm num} - u_{\rm exact}}{u_{\rm exact}}\right| \\
&\propto \Delta x^4 \\
\implies E_{\rm Rel} &= k \Delta x^4,
\end{align} where \(k\) is the proportionality constant, divided by
\(u_{\rm exact}\).

Therefore, taking the logarithm of both sides of the equation, we get:

\begin{align}
\log_{10} E_{\rm Rel} &= \log_{10} (k [\Delta x]^4) \\
&= \log_{10} ([\Delta x]^4) + \log_{10} (k) \\
&= 4 \log_{10} (\Delta x) + \log_{10} (k)
\end{align}

\(\Delta x\) is proportional to \texttt{1/Nx}, so if we perform the
simulation at twice the resolution (i.e., \(\Delta x\to \Delta x/2\)),
\(\log_{10} E_{\rm Rel}\) should drop by

\begin{align}
4 \log_{10} (\Delta x) - 4 \log_{10} (\Delta x/2) &= 4 \log_{10} \frac{\Delta x}{\Delta x/2} \\
&= 4 \log_{10} 2 \approx 1.20.
\end{align}

In the below plot we show that when the logarithmic relative error
\(\log_{10} E_{\rm Rel}\) versus time in the \(48^3\) case is shifted
upward by 1.2 (or for the \(96^3\) case by 2.4), we observe perfect
overlap with \(\log_{10} E_{\rm Rel}\) in the \(24^3\) case (except at
\(t=0\) when the numerical solution is set to the exact solution). This
is a common way in numerical relativity to present convergence of
numerical errors to zero, demonstrating that our code is working as
expected.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{c+c1}{\PYZsh{} from https://stackoverflow.com/questions/52386747/matplotlib\PYZhy{}check\PYZhy{}for\PYZhy{}empty\PYZhy{}plot}
\PY{k+kn}{import} \PY{n+nn}{numpy}
\PY{n}{time\PYZus{}\PYZus{}arr} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{lgerr\PYZus{}arr} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{p}{[}\PY{l+m+mi}{24}\PY{p}{,} \PY{l+m+mi}{48}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{]}\PY{p}{:}
    \PY{n}{t}\PY{p}{,} \PY{n}{log10error}\PY{p}{,} \PY{n}{num}\PY{p}{,} \PY{n}{exact} \PY{o}{=} \PY{n}{numpy}\PY{o}{.}\PY{n}{loadtxt}\PY{p}{(}\PY{n}{fname}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{output\PYZus{}resolution\PYZus{}}\PY{l+s+s1}{\PYZsq{}}\PY{o}{+}\PY{n+nb}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{o}{+}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{cubed.txt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{delimiter}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{unpack}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
    \PY{n}{time\PYZus{}\PYZus{}arr}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{t}\PY{p}{)}
    \PY{n}{lgerr\PYZus{}single\PYZus{}dataset} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{k}{if} \PY{n}{i} \PY{o}{!=} \PY{l+m+mi}{24}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Moving from 24\PYZca{}3 grid to }\PY{l+s+s2}{\PYZdq{}}
              \PY{o}{+}\PY{n+nb}{str}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZca{}3 grid, logarithmic drop in numerical error should be }\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZpc{}.2f}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{p}{(}\PY{l+m+mi}{4}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{log10}\PY{p}{(}\PY{n}{i}\PY{o}{/}\PY{p}{(}\PY{l+m+mf}{24.0}\PY{p}{)}\PY{p}{)}\PY{p}{)}\PY{p}{)}
    \PY{k}{for} \PY{n}{log10err\PYZus{}onept} \PY{o+ow}{in} \PY{n}{log10error}\PY{p}{:}
        \PY{n}{lgerr\PYZus{}single\PYZus{}dataset}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{log10err\PYZus{}onept} \PY{o}{+} \PY{l+m+mi}{4}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{log10}\PY{p}{(}\PY{n}{i}\PY{o}{/}\PY{p}{(}\PY{l+m+mf}{24.0}\PY{p}{)}\PY{p}{)}\PY{p}{)}
    \PY{n}{lgerr\PYZus{}arr}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{lgerr\PYZus{}single\PYZus{}dataset}\PY{p}{)}

\PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{time}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{log10(|Relative Error|)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{time\PYZus{}\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{lgerr\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{time\PYZus{}\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{lgerr\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{r}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{time\PYZus{}\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{lgerr\PYZus{}arr}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{color}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{g}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Moving from 24\^{}3 grid to 48\^{}3 grid, logarithmic drop in numerical error should
be 1.20
Moving from 24\^{}3 grid to 96\^{}3 grid, logarithmic drop in numerical error should
be 2.41
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
[<matplotlib.lines.Line2D at 0x7f64fd9769e0>]
\end{Verbatim}
\end{tcolorbox}
        
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{Tutorial-Solving_the_Scalar_Wave_Equation_with_NumPy_files/Tutorial-Solving_the_Scalar_Wave_Equation_with_NumPy_42_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{step-6-exercises-for-students-back-to-top}{%
\section{\texorpdfstring{Step 6: Exercises for students {[}Back to
\hyperref[toc]{top}{]}}{Step 6: Exercises for students {[}Back to {]}}}\label{step-6-exercises-for-students-back-to-top}}

\[\label{student_exercises}\]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Adjust the above code to make it run twice as fast on the same
  numerical grid, while generating exactly the same results (stored to
  files above). \emph{Bonus}: Can you make it run any faster than twice
  as fast (while still being written in ``pure'' Python, using
  \texttt{NumPy})?
\item
  How much should the (absolute value of the) relative error
  \texttt{\textbar{}rel\_error\textbar{}} drop if we were to double the
  resolution, assuming instead 6th-order convergence? How will this
  adjust the \texttt{log10(\textbar{}rel\_error\textbar{})}?
\item
  Why did we add a nonzero constant offset to the exact solution?
  (\emph{Hint: Start from the definition of relative error.})
\item
  What will happen to the convergence order if we continue the
  simulation for a much longer time, say to \(t=2\)? Why? (\emph{Hint:
  Convergence order will plummet!})
\end{enumerate}

    \hypertarget{step-7-output-this-notebook-to-latex-formatted-pdf-file-back-to-top}{%
\section{\texorpdfstring{Step 7: Output this notebook to
\(\LaTeX\)-formatted PDF file {[}Back to
\hyperref[toc]{top}{]}}{Step 7: Output this notebook to \textbackslash LaTeX-formatted PDF file {[}Back to {]}}}\label{step-7-output-this-notebook-to-latex-formatted-pdf-file-back-to-top}}

\[\label{latex_pdf_output}\]

The following code cell converts this Jupyter notebook into a proper,
clickable \(\LaTeX\)-formatted PDF file. After the cell is successfully
run, the generated PDF may be found in the root NRPy+ tutorial
directory, with filename
\url{Tutorial-Solving_the_Scalar_Wave_Equation_with_NumPy.pdf} (Note
that clicking on this link may not work; you may need to open the PDF
file through another means.)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{cmdline\PYZus{}helper} \PY{k}{as} \PY{n+nn}{cmd}    \PY{c+c1}{\PYZsh{} NRPy+: Multi\PYZhy{}platform Python command\PYZhy{}line interface}
\PY{n}{cmd}\PY{o}{.}\PY{n}{output\PYZus{}Jupyter\PYZus{}notebook\PYZus{}to\PYZus{}LaTeXed\PYZus{}PDF}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Tutorial\PYZhy{}Solving\PYZus{}the\PYZus{}Scalar\PYZus{}Wave\PYZus{}Equation\PYZus{}with\PYZus{}NumPy}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Created Tutorial-Solving\_the\_Scalar\_Wave\_Equation\_with\_NumPy.tex, and
    compiled LaTeX file to PDF file Tutorial-
    Solving\_the\_Scalar\_Wave\_Equation\_with\_NumPy.pdf
    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
