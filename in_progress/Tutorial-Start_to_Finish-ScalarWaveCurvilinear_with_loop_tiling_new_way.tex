% Based on http://nbviewer.jupyter.org/github/ipython/nbconvert-examples/blob/master/citations/Tutorial.ipynb , authored by Brian E. Granger
    % Declare the document class
    \documentclass[landscape,letterpaper,10pt,english]{article}


    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Tutorial-Start\_to\_Finish-ScalarWaveCurvilinear\_with\_loop\_tiling\_new\_way}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
% Start the section counter at -1, so the Table of Contents is Section 0
   \setcounter{section}{-2}
% Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }

    % Slightly bigger margins than the latex defaults
    \geometry{verbose,tmargin=0.5in,bmargin=0.5in,lmargin=0.5in,rmargin=0.5in}


\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{start-to-finish-example-numerical-solution-of-the-scalar-wave-equation-in-curvilinear-coordinates-with-loop-tiling}{%
\section{Start-to-Finish Example: Numerical Solution of the Scalar Wave
Equation, in Curvilinear Coordinates with Loop
Tiling}\label{start-to-finish-example-numerical-solution-of-the-scalar-wave-equation-in-curvilinear-coordinates-with-loop-tiling}}

\hypertarget{author-leo-werneck-zach-etienne}{%
\subsection{Author: Leo Werneck \& Zach
Etienne}\label{author-leo-werneck-zach-etienne}}

\hypertarget{formatting-improvements-courtesy-brandon-clark}{%
\subsubsection{Formatting improvements courtesy Brandon
Clark}\label{formatting-improvements-courtesy-brandon-clark}}

\hypertarget{this-module-solves-the-scalar-wave-equation-in-spherical-coordinates-though-other-coordinates-including-cartesian-may-be-chosen-using-loop-tiling.}{%
\subsection{\texorpdfstring{This module solves the scalar wave equation
in \emph{spherical coordinates} (though other coordinates, including
Cartesian, may be chosen) using
\href{https://en.wikipedia.org/wiki/Loop_nest_optimization}{loop
tiling}.}{This module solves the scalar wave equation in spherical coordinates (though other coordinates, including Cartesian, may be chosen) using loop tiling.}}\label{this-module-solves-the-scalar-wave-equation-in-spherical-coordinates-though-other-coordinates-including-cartesian-may-be-chosen-using-loop-tiling.}}

\textbf{Notebook Status:} Validated

\textbf{Validation Notes:} This module has been validated to converge at
the expected order to the exact solution (see
\hyperref[convergence]{plot} at bottom).

\hypertarget{nrpy-source-code-for-this-module}{%
\subsubsection{NRPy+ Source Code for this
module:}\label{nrpy-source-code-for-this-module}}

\begin{itemize}
\tightlist
\item
  \href{../edit/ScalarWave/ScalarWaveCurvilinear_RHSs.py}{ScalarWave/ScalarWaveCurvilinear\_RHSs.py}
  \href{Tutorial-ScalarWaveCurvilinear.ipynb}{{[}\textbf{tutorial}{]}}
  Generates the right-hand side for the Scalar Wave Equation in
  curvilinear coordinates
\item
  \href{../edit/ScalarWave/InitialData.py}{ScalarWave/InitialData.py}
  \href{Tutorial-ScalarWave.ipynb}{{[}\textbf{tutorial}{]}} Generating C
  code for either plane wave or spherical Gaussian initial data for the
  scalar wave equation
\end{itemize}

\hypertarget{introduction}{%
\subsection{Introduction:}\label{introduction}}

As outlined in the \href{Tutorial-ScalarWaveCurvilinear.ipynb}{previous
NRPy+ tutorial notebook}, we first use NRPy+ to generate initial data
for the scalar wave equation, and then we use it to generate the RHS
expressions for
\href{https://reference.wolfram.com/language/tutorial/NDSolveMethodOfLines.html}{Method
of Lines} time integration based on the
\href{https://en.wikipedia.org/wiki/Runge\%E2\%80\%93Kutta_methods}{explicit
Runge-Kutta fourth-order scheme} (RK4).

The entire algorithm is outlined below, with NRPy+-based components
highlighted in green.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Allocate memory for gridfunctions, including temporary storage for the
  RK4 time integration.
\item
  Set gridfunction values to initial data.
\item
  Evolve the system forward in time using RK4 time integration. At each
  RK4 substep, do the following:

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    Evaluate scalar wave RHS expressions.
  \item
    Apply boundary conditions.
  \end{enumerate}
\item
  At the end of each iteration in time, output the relative error
  between numerical and exact solutions.
\end{enumerate}

    \hypertarget{table-of-contents}{%
\section{Table of Contents}\label{table-of-contents}}

\[\label{toc}\]

This notebook is organized as follows

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \hyperref[writec]{Step 1}: Generate C code to solve the scalar wave
  equation in curvilinear coordinates

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    \hyperref[id_rhss]{Step 1.a}: C code generation: Initial data and
    scalar wave right-hand-sides
  \item
    \hyperref[boundaryconditions]{Step 1.b}: C code generation: Boundary
    condition driver
  \item
    \hyperref[cparams_rfm_and_domainsize]{Step 1.c}: Generate
    Cparameters files; set reference metric parameters, including
    \texttt{domain\_size}
  \item
    \hyperref[cfl]{Step 1.d}: C code generation: Finding the minimum
    proper distance between grid points, needed for
    \href{https://en.wikipedia.org/w/index.php?title=Courant\%E2\%80\%93Friedrichs\%E2\%80\%93Lewy_condition\&oldid=806430673}{CFL}-limited
    timestep
  \end{enumerate}
\item
  \hyperref[mainc]{Step 2}: The C code \texttt{main()} function for
  \texttt{ScalarWaveCurvilinear\_Playground}
\item
  \hyperref[compileexec]{Step 3}: Compile generated C codes \& solve the
  scalar wave equation
\item
  \hyperref[convergence]{Step 4}: Code validation: Plot the numerical
  error, and confirm that it converges to zero at expected rate with
  increasing numerical resolution (sampling)
\item
  \hyperref[latex_pdf_output]{Step 5}: Output this notebook to
  \(\LaTeX\)-formatted PDF file
\end{enumerate}

    \hypertarget{step-1-using-nrpy-to-generate-necessary-c-code-to-solve-the-scalar-wave-equation-in-curvilinear-singular-coordinates-back-to-top}{%
\section{\texorpdfstring{Step 1: Using NRPy+ to generate necessary C
code to solve the scalar wave equation in curvilinear, singular
coordinates {[}Back to
\hyperref[toc]{top}{]}}{Step 1: Using NRPy+ to generate necessary C code to solve the scalar wave equation in curvilinear, singular coordinates {[}Back to {]}}}\label{step-1-using-nrpy-to-generate-necessary-c-code-to-solve-the-scalar-wave-equation-in-curvilinear-singular-coordinates-back-to-top}}

\[\label{writec}\]

    \hypertarget{step-1.a-c-code-generation-initial-data-and-scalar-wave-rhss-back-to-top}{%
\subsection{\texorpdfstring{Step 1.a: C code generation: Initial data
and scalar wave RHSs {[}Back to
\hyperref[toc]{top}{]}}{Step 1.a: C code generation: Initial data and scalar wave RHSs {[}Back to {]}}}\label{step-1.a-c-code-generation-initial-data-and-scalar-wave-rhss-back-to-top}}

\[\label{id_rhss}\]

We choose simple plane wave initial data, which is documented in the
\href{Tutorial-ScalarWave.ipynb}{Cartesian scalar wave module}.
Specifically, we implement monochromatic (single-wavelength) wave
traveling in the \(\hat{k}\) direction with speed \(c\)
\[u(\vec{x},t) = f(\hat{k}\cdot\vec{x} - c t),\] where \(\hat{k}\) is a
unit vector.

The scalar wave RHSs in curvilinear coordinates (documented
\href{Tutorial-ScalarWaveCurvilinear.ipynb}{in the previous module}) are
simply the right-hand sides of the scalar wave equation written in
curvilinear coordinates \begin{align}
\partial_t u &= v \\
\partial_t v &= c^2 \left(\hat{g}^{ij} \partial_{i} \partial_{j} u - \hat{\Gamma}^i \partial_i u\right),
\end{align} where \(\hat{g}^{ij}\) is the inverse reference 3-metric
(i.e., the metric corresponding to the underlying coordinate system we
choose\(-\)spherical coordinates in our example below), and
\(\hat{\Gamma}^i\) is the contracted Christoffel symbol
\(\hat{\Gamma}^\tau = \hat{g}^{\mu\nu} \hat{\Gamma}^\tau_{\mu\nu}\).

Below we generate + the initial data by calling
\texttt{InitialData(Type="PlaneWave")} inside the NRPy+
\href{../edit/ScalarWave/InitialData.py}{ScalarWave/InitialData.py}
module (documented in \href{Tutorial-ScalarWave.ipynb}{this NRPy+
Jupyter notebook}), and + the RHS expressions by calling
\texttt{ScalarWaveCurvilinear\_RHSs()} inside the NRPy+
\href{../edit/ScalarWave/ScalarWaveCurvilinear_RHSs.py}{ScalarWave/ScalarWaveCurvilinear\_RHSs.py}
module (documented in \href{Tutorial-ScalarWaveCurvilinear.ipynb}{this
NRPy+ Jupyter notebook}).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Step P1: Import needed NRPy+ core modules:}
\PY{k+kn}{import} \PY{n+nn}{shutil}\PY{o}{,} \PY{n+nn}{os}\PY{o}{,} \PY{n+nn}{sys}                \PY{c+c1}{\PYZsh{} Standard Python modules for multiplatform OS\PYZhy{}level functions}
\PY{n}{sys}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{..}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{k+kn}{from} \PY{n+nn}{outputC} \PY{k+kn}{import} \PY{n}{lhrh}\PY{p}{,} \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict}  \PY{c+c1}{\PYZsh{} NRPy+: Core C code output module}
\PY{k+kn}{import} \PY{n+nn}{finite\PYZus{}difference} \PY{k}{as} \PY{n+nn}{fin}       \PY{c+c1}{\PYZsh{} NRPy+: Finite difference C code generation module}
\PY{k+kn}{import} \PY{n+nn}{NRPy\PYZus{}param\PYZus{}funcs} \PY{k}{as} \PY{n+nn}{par}        \PY{c+c1}{\PYZsh{} NRPy+: Parameter interface}
\PY{k+kn}{import} \PY{n+nn}{grid} \PY{k}{as} \PY{n+nn}{gri}                    \PY{c+c1}{\PYZsh{} NRPy+: Functions having to do with numerical grids}
\PY{k+kn}{import} \PY{n+nn}{reference\PYZus{}metric} \PY{k}{as} \PY{n+nn}{rfm}        \PY{c+c1}{\PYZsh{} NRPy+: Reference metric support}
\PY{k+kn}{import} \PY{n+nn}{cmdline\PYZus{}helper} \PY{k}{as} \PY{n+nn}{cmd}          \PY{c+c1}{\PYZsh{} NRPy+: Multi\PYZhy{}platform Python command\PYZhy{}line interface}

\PY{c+c1}{\PYZsh{} Step P2: Create C code output directory:}
\PY{n}{Ccodesrootdir} \PY{o}{=} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ScalarWaveCurvilinear\PYZus{}Playground\PYZus{}Ccodes\PYZus{}with\PYZus{}loop\PYZus{}tiling\PYZus{}new\PYZus{}way}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{c+c1}{\PYZsh{} First remove C code output directory if it exists}
\PY{c+c1}{\PYZsh{} Courtesy https://stackoverflow.com/questions/303200/how\PYZhy{}do\PYZhy{}i\PYZhy{}remove\PYZhy{}delete\PYZhy{}a\PYZhy{}folder\PYZhy{}that\PYZhy{}is\PYZhy{}not\PYZhy{}empty}
\PY{n}{shutil}\PY{o}{.}\PY{n}{rmtree}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{n}{ignore\PYZus{}errors}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Then create a fresh directory}
\PY{n}{cmd}\PY{o}{.}\PY{n}{mkdir}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step P3: Create executable output directory:}
\PY{n}{outdir} \PY{o}{=} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{cmd}\PY{o}{.}\PY{n}{mkdir}\PY{p}{(}\PY{n}{outdir}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step P4: Enable/disable SIMD. If enabled, code should run \PYZti{}2x faster on most CPUs.}
\PY{n}{enable\PYZus{}SIMD} \PY{o}{=} \PY{k+kc}{False}

\PY{c+c1}{\PYZsh{} Step P5: Enable reference metric precomputation.}
\PY{n}{enable\PYZus{}rfm\PYZus{}precompute} \PY{o}{=} \PY{k+kc}{True}
\PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::rfm\PYZus{}precompute\PYZus{}to\PYZus{}Cfunctions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{True}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{k}{if} \PY{n}{enable\PYZus{}SIMD} \PY{o+ow}{and} \PY{o+ow}{not} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ERROR: SIMD does not currently handle transcendental functions,}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{       like those found in rfmstruct (rfm\PYZus{}precompute).}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{       Therefore, enable\PYZus{}SIMD==True and enable\PYZus{}rfm\PYZus{}precompute==False}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{       is not supported.}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{sys}\PY{o}{.}\PY{n}{exit}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step P6: Enable \PYZdq{}FD functions\PYZdq{}. In other words, all finite\PYZhy{}difference stencils}
\PY{c+c1}{\PYZsh{}         will be output as inlined static functions. This is essential for}
\PY{c+c1}{\PYZsh{}         compiling highly complex FD kernels with using certain versions of GCC;}
\PY{c+c1}{\PYZsh{}         GCC 10\PYZhy{}ish will choke on BSSN FD kernels at high FD order, sometimes}
\PY{c+c1}{\PYZsh{}         taking *hours* to compile. Unaffected GCC versions compile these kernels}
\PY{c+c1}{\PYZsh{}         in seconds. FD functions do not slow the code performance, but do add}
\PY{c+c1}{\PYZsh{}         another header file to the C source tree.}
\PY{c+c1}{\PYZsh{} With gcc 7.5.0, enable\PYZus{}FD\PYZus{}functions=True decreases performance by 10\PYZpc{}}
\PY{n}{enable\PYZus{}FD\PYZus{}functions} \PY{o}{=} \PY{k+kc}{False}

\PY{c+c1}{\PYZsh{} Step 1: Set some core parameters, including CoordSystem, boundary condition,}
\PY{c+c1}{\PYZsh{}                                             MoL, timestepping algorithm, FD order,}
\PY{c+c1}{\PYZsh{}                                             floating point precision, and CFL factor:}

\PY{c+c1}{\PYZsh{} Step 1.a: Set the coordinate system for the numerical grid}
\PY{c+c1}{\PYZsh{} Choices are: Spherical, SinhSpherical, SinhSphericalv2, Cylindrical, SinhCylindrical,}
\PY{c+c1}{\PYZsh{}              SymTP, SinhSymTP}
\PY{n}{CoordSystem}     \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{SinhSpherical}\PY{l+s+s2}{\PYZdq{}}
\PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::CoordSystem}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{CoordSystem}\PY{p}{)}
\PY{n}{rfm}\PY{o}{.}\PY{n}{reference\PYZus{}metric}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step 1.b: Set boundary conditions}
\PY{c+c1}{\PYZsh{} Current choices are QuadraticExtrapolation (quadratic polynomial extrapolation) or Sommerfeld}
\PY{n}{BoundaryCondition} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{QuadraticExtrapolation}\PY{l+s+s2}{\PYZdq{}}

\PY{c+c1}{\PYZsh{} Step 1.c: Set defaults for Coordinate system parameters.}
\PY{c+c1}{\PYZsh{}           These are perhaps the most commonly adjusted parameters,}
\PY{c+c1}{\PYZsh{}           so we enable modifications at this high level.}

\PY{c+c1}{\PYZsh{} domain\PYZus{}size sets the default value for:}
\PY{c+c1}{\PYZsh{}   * Spherical\PYZsq{}s params.RMAX}
\PY{c+c1}{\PYZsh{}   * SinhSpherical*\PYZsq{}s params.AMAX}
\PY{c+c1}{\PYZsh{}   * Cartesians*\PYZsq{}s \PYZhy{}params.\PYZob{}x,y,z\PYZcb{}min \PYZam{} .\PYZob{}x,y,z\PYZcb{}max}
\PY{c+c1}{\PYZsh{}   * Cylindrical\PYZsq{}s \PYZhy{}params.ZMIN \PYZam{} .\PYZob{}Z,RHO\PYZcb{}MAX}
\PY{c+c1}{\PYZsh{}   * SinhCylindrical\PYZsq{}s params.AMPL\PYZob{}RHO,Z\PYZcb{}}
\PY{c+c1}{\PYZsh{}   * *SymTP\PYZsq{}s params.AMAX}
\PY{n}{domain\PYZus{}size}     \PY{o}{=} \PY{l+m+mf}{10.0} \PY{c+c1}{\PYZsh{} Needed for all coordinate systems.}

\PY{c+c1}{\PYZsh{} sinh\PYZus{}width sets the default value for:}
\PY{c+c1}{\PYZsh{}   * SinhSpherical\PYZsq{}s params.SINHW}
\PY{c+c1}{\PYZsh{}   * SinhCylindrical\PYZsq{}s params.SINHW\PYZob{}RHO,Z\PYZcb{}}
\PY{c+c1}{\PYZsh{}   * SinhSymTP\PYZsq{}s params.SINHWAA}
\PY{n}{sinh\PYZus{}width}      \PY{o}{=} \PY{l+m+mf}{0.4} \PY{c+c1}{\PYZsh{} If Sinh* coordinates chosen}

\PY{c+c1}{\PYZsh{} sinhv2\PYZus{}const\PYZus{}dr sets the default value for:}
\PY{c+c1}{\PYZsh{}   * SinhSphericalv2\PYZsq{}s params.const\PYZus{}dr}
\PY{c+c1}{\PYZsh{}   * SinhCylindricalv2\PYZsq{}s params.const\PYZus{}d\PYZob{}rho,z\PYZcb{}}
\PY{n}{sinhv2\PYZus{}const\PYZus{}dr} \PY{o}{=} \PY{l+m+mf}{0.05}\PY{c+c1}{\PYZsh{} If Sinh*v2 coordinates chosen}

\PY{c+c1}{\PYZsh{} SymTP\PYZus{}bScale sets the default value for:}
\PY{c+c1}{\PYZsh{}   * SinhSymTP\PYZsq{}s params.bScale}
\PY{n}{SymTP\PYZus{}bScale}    \PY{o}{=} \PY{l+m+mf}{1.0} \PY{c+c1}{\PYZsh{} If SymTP chosen}

\PY{c+c1}{\PYZsh{} Step 1.d: Set the order of spatial and temporal derivatives;}
\PY{c+c1}{\PYZsh{}           the core data type, and the CFL factor.}
\PY{c+c1}{\PYZsh{} RK\PYZus{}method choices include: Euler, \PYZdq{}RK2 Heun\PYZdq{}, \PYZdq{}RK2 MP\PYZdq{}, \PYZdq{}RK2 Ralston\PYZdq{}, RK3, \PYZdq{}RK3 Heun\PYZdq{}, \PYZdq{}RK3 Ralston\PYZdq{},}
\PY{c+c1}{\PYZsh{}              SSPRK3, RK4, DP5, DP5alt, CK5, DP6, L6, DP8}
\PY{n}{RK\PYZus{}method} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{RK4}\PY{l+s+s2}{\PYZdq{}}
\PY{n}{FD\PYZus{}order}  \PY{o}{=} \PY{l+m+mi}{4}        \PY{c+c1}{\PYZsh{} Finite difference order: even numbers only, starting with 2. 12 is generally unstable}
\PY{n}{REAL}      \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{double}\PY{l+s+s2}{\PYZdq{}} \PY{c+c1}{\PYZsh{} Best to use double here.}
\PY{n}{CFL\PYZus{}FACTOR}\PY{o}{=} \PY{l+m+mf}{1.0}

\PY{c+c1}{\PYZsh{} Step 1.e: Tile parameters}
\PY{n}{\PYZus{}}\PY{p}{,}\PY{n}{\PYZus{}}\PY{p}{,}\PY{n}{\PYZus{}}\PY{p}{,}\PY{n}{\PYZus{}}\PY{p}{,}\PY{n}{\PYZus{}}\PY{p}{,}\PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{par}\PY{o}{.}\PY{n}{Cparameters}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{int}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ScalarWaveCurvilinear}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                              \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize0}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                               \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                               \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                               \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize\PYZus{}plus\PYZus{}2NGHOSTS0}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                               \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize\PYZus{}plus\PYZus{}2NGHOSTS1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                               \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{tilesize\PYZus{}plus\PYZus{}2NGHOSTS2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{,}
                              \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Step 2: Import the ScalarWave.InitialData module.}
\PY{c+c1}{\PYZsh{}         This command only declares ScalarWave initial data}
\PY{c+c1}{\PYZsh{}         parameters and the InitialData() function.}
\PY{k+kn}{import} \PY{n+nn}{ScalarWave}\PY{n+nn}{.}\PY{n+nn}{InitialData} \PY{k}{as} \PY{n+nn}{swid}

\PY{c+c1}{\PYZsh{} Step 3: Import ScalarWave\PYZus{}RHSs module.}
\PY{c+c1}{\PYZsh{}         This command only declares ScalarWave RHS parameters}
\PY{c+c1}{\PYZsh{}         and the ScalarWave\PYZus{}RHSs function (called later)}
\PY{k+kn}{import} \PY{n+nn}{ScalarWave}\PY{n+nn}{.}\PY{n+nn}{ScalarWaveCurvilinear\PYZus{}RHSs} \PY{k}{as} \PY{n+nn}{swrhs}

\PY{c+c1}{\PYZsh{} Step 4: Call the InitialData() function to set up initial data.}
\PY{c+c1}{\PYZsh{}         Options include:}
\PY{c+c1}{\PYZsh{}    \PYZdq{}PlaneWave\PYZdq{}: monochromatic (single frequency/wavelength) plane wave}
\PY{c+c1}{\PYZsh{}    \PYZdq{}SphericalGaussian\PYZdq{}: spherically symmetric Gaussian, with default stdev=3}
\PY{n}{swid}\PY{o}{.}\PY{n}{InitialData}\PY{p}{(}\PY{n}{CoordSystem}\PY{o}{=}\PY{n}{CoordSystem}\PY{p}{,}\PY{n}{Type}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{PlaneWave}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step 5: Set the finite differencing order to FD\PYZus{}order (set above).}
\PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{finite\PYZus{}difference::FD\PYZus{}CENTDERIVS\PYZus{}ORDER}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{FD\PYZus{}order}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step 6: Generate SymPy symbolic expressions for}
\PY{c+c1}{\PYZsh{}         uu\PYZus{}rhs and vv\PYZus{}rhs; the ScalarWave RHSs.}
\PY{c+c1}{\PYZsh{}         This function also declares the uu and vv}
\PY{c+c1}{\PYZsh{}         gridfunctions, which need to be declared}
\PY{c+c1}{\PYZsh{}         to output even the initial data to C file.}
\PY{c+c1}{\PYZsh{} First get into the enable\PYZus{}rfm\PYZus{}precompute environment, if enable\PYZus{}rfm\PYZus{}precompute==True}
\PY{k}{if} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
    \PY{n}{cmd}\PY{o}{.}\PY{n}{mkdir}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfm\PYZus{}files/}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
    \PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::enable\PYZus{}rfm\PYZus{}precompute}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{True}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::rfm\PYZus{}precompute\PYZus{}Ccode\PYZus{}outdir}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfm\PYZus{}files/}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}

\PY{n}{swrhs}\PY{o}{.}\PY{n}{ScalarWaveCurvilinear\PYZus{}RHSs}\PY{p}{(}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Step 6.a: Now that we are finished with all the rfm hatted}
\PY{c+c1}{\PYZsh{}           quantities, let\PYZsq{}s restore them to their closed\PYZhy{}}
\PY{c+c1}{\PYZsh{}           form expressions.}
\PY{k}{if} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
    \PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::enable\PYZus{}rfm\PYZus{}precompute}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{False}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{c+c1}{\PYZsh{} Reset to False to disable rfm\PYZus{}precompute.}
\PY{n}{rfm}\PY{o}{.}\PY{n}{ref\PYZus{}metric\PYZus{}\PYZus{}hatted\PYZus{}quantities}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step 7: Copy SIMD/SIMD\PYZus{}intrinsics.h to \PYZdl{}Ccodesrootdir/SIMD/SIMD\PYZus{}intrinsics.h}
\PY{k}{if} \PY{n}{enable\PYZus{}SIMD}\PY{p}{:}
    \PY{n}{cmd}\PY{o}{.}\PY{n}{mkdir}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{SIMD}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
    \PY{n}{shutil}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{../SIMD/}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{SIMD\PYZus{}intrinsics.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{SIMD/}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Step 8: Set enable \PYZdq{}FD functions\PYZdq{} parameter. See above for details.}
\PY{n}{par}\PY{o}{.}\PY{n}{set\PYZus{}parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{finite\PYZus{}difference::enable\PYZus{}FD\PYZus{}functions}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{enable\PYZus{}FD\PYZus{}functions}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-1.b-generate-method-of-lines-timestepping-code-back-to-top}{%
\subsection{\texorpdfstring{Step 1.b: Generate Method of Lines
timestepping code {[}Back to
\hyperref[toc]{top}{]}}{Step 1.b: Generate Method of Lines timestepping code {[}Back to {]}}}\label{step-1.b-generate-method-of-lines-timestepping-code-back-to-top}}

\[\label{mol}\]

The Method of Lines algorithm is described in detail in the
\href{Tutorial-Method_of_Lines-C_Code_Generation.ipynb}{\textbf{NRPy+
tutorial notebook on Method of Lines algorithm}}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Step 10: Generate Runge\PYZhy{}Kutta\PYZhy{}based (RK\PYZhy{}based) timestepping code.}
\PY{c+c1}{\PYZsh{}       As described above the Table of Contents, this is a 2\PYZhy{}step process:}
\PY{c+c1}{\PYZsh{}       1.b.A: Evaluate RHSs (RHS\PYZus{}string)}
\PY{c+c1}{\PYZsh{}       1.b.B: Apply boundary conditions (post\PYZus{}RHS\PYZus{}string, pt 1)}
\PY{k+kn}{import} \PY{n+nn}{MoLtimestepping}\PY{n+nn}{.}\PY{n+nn}{MoL\PYZus{}new\PYZus{}way} \PY{k}{as} \PY{n+nn}{MoL}
\PY{c+c1}{\PYZsh{} from MoLtimestepping.RK\PYZus{}Butcher\PYZus{}Table\PYZus{}Dictionary import Butcher\PYZus{}dict}
\PY{c+c1}{\PYZsh{} RK\PYZus{}order  = Butcher\PYZus{}dict[RK\PYZus{}method][1]}
\PY{n}{RHS\PYZus{}string} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rhs\PYZus{}eval(params, rfmstruct, RK\PYZus{}INPUT\PYZus{}GFS, RK\PYZus{}OUTPUT\PYZus{}GFS);}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{o+ow}{not} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
    \PY{n}{RHS\PYZus{}string} \PY{o}{=} \PY{n}{RHS\PYZus{}string}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfmstruct}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{xx}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{k}{if} \PY{n}{BoundaryCondition} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{QuadraticExtrapolation}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Extrapolation BCs are applied to the evolved gridfunctions themselves after the MoL update}
    \PY{n}{post\PYZus{}RHS\PYZus{}string} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apply\PYZus{}bcs\PYZus{}curvilinear(params, bcstruct, NUM\PYZus{}EVOL\PYZus{}GFS, evol\PYZus{}gf\PYZus{}parity, RK\PYZus{}OUTPUT\PYZus{}GFS);}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{elif} \PY{n}{BoundaryCondition} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Sommerfeld}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Sommerfeld BCs are applied to the gridfunction RHSs directly}
    \PY{n}{RHS\PYZus{}string} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{apply\PYZus{}bcs\PYZus{}sommerfeld(params, xx, bcstruct, NUM\PYZus{}EVOL\PYZus{}GFS, evol\PYZus{}gf\PYZus{}parity, RK\PYZus{}INPUT\PYZus{}GFS, RK\PYZus{}OUTPUT\PYZus{}GFS);}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{post\PYZus{}RHS\PYZus{}string} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{else}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Invalid choice of boundary condition}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{sys}\PY{o}{.}\PY{n}{exit}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}

\PY{n}{MoL}\PY{o}{.}\PY{n}{register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{n}{RK\PYZus{}method}\PY{p}{,}
        \PY{n}{RHS\PYZus{}string}\PY{o}{=}\PY{n}{RHS\PYZus{}string}\PY{p}{,} \PY{n}{post\PYZus{}RHS\PYZus{}string}\PY{o}{=}\PY{n}{post\PYZus{}RHS\PYZus{}string}\PY{p}{,}
        \PY{n}{enable\PYZus{}rfm}\PY{o}{=}\PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{,} \PY{n}{enable\PYZus{}curviBCs}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{enable\PYZus{}SIMD}\PY{o}{=}\PY{n}{enable\PYZus{}SIMD}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}exact\PYZus{}solution\PYZus{}single\PYZus{}point}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{includes} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}basic\PYZus{}defines.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}function\PYZus{}prototypes.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{n}{desc} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Exact solution at a single point. params.time==0 corresponds to the initial data.}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{c\PYZus{}type} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{void}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{exact\PYZus{}solution\PYZus{}single\PYZus{}point}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{params} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{const paramstruct *restrict params,}
\PY{l+s+s2}{                const REAL xx0, const REAL xx1, const REAL xx2,}
\PY{l+s+s2}{                REAL *uu\PYZus{}exact, REAL *vv\PYZus{}exact}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{body} \PY{o}{=} \PY{n}{fin}\PY{o}{.}\PY{n}{FD\PYZus{}outputC}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{returnstring}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{p}{[}\PY{n}{lhrh}\PY{p}{(}\PY{n}{lhs}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{*uu\PYZus{}exact}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{rhs}\PY{o}{=}\PY{n}{swid}\PY{o}{.}\PY{n}{uu\PYZus{}ID}\PY{p}{)}\PY{p}{,}
                                          \PY{n}{lhrh}\PY{p}{(}\PY{n}{lhs}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{*vv\PYZus{}exact}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{rhs}\PY{o}{=}\PY{n}{swid}\PY{o}{.}\PY{n}{vv\PYZus{}ID}\PY{p}{)}\PY{p}{]}\PY{p}{,}
                          \PY{n}{params}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{includebraces=False,preindent=1,outCverbose=False}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict}\PY{p}{(}
        \PY{n}{includes}\PY{o}{=}\PY{n}{includes}\PY{p}{,}
        \PY{n}{desc}\PY{o}{=}\PY{n}{desc}\PY{p}{,}
        \PY{n}{c\PYZus{}type}\PY{o}{=}\PY{n}{c\PYZus{}type}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{n}{name}\PY{p}{,} \PY{n}{params}\PY{o}{=}\PY{n}{params}\PY{p}{,}
        \PY{n}{body}\PY{o}{=}\PY{n}{body}\PY{p}{,}
        \PY{n}{rel\PYZus{}path\PYZus{}to\PYZus{}Cparams}\PY{o}{=}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}exact\PYZus{}solution\PYZus{}all\PYZus{}points}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{includes} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}basic\PYZus{}defines.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}function\PYZus{}prototypes.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{n}{desc} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Exact solution at all points. params.time==0 corresponds to the initial data.}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{c\PYZus{}type} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{void}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{exact\PYZus{}solution\PYZus{}all\PYZus{}points}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{params} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{const paramstruct *restrict params,REAL *restrict xx[3], REAL *restrict in\PYZus{}gfs}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{body} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{exact\PYZus{}solution\PYZus{}single\PYZus{}point(params, xx0, xx1, xx2,}
\PY{l+s+s2}{           \PYZam{}in\PYZus{}gfs[IDX4S(UUGF,i0,i1,i2)], \PYZam{}in\PYZus{}gfs[IDX4S(VVGF,i0,i1,i2)]);}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict}\PY{p}{(}
        \PY{n}{includes}\PY{o}{=}\PY{n}{includes}\PY{p}{,}
        \PY{n}{desc}\PY{o}{=}\PY{n}{desc}\PY{p}{,}
        \PY{n}{c\PYZus{}type}\PY{o}{=}\PY{n}{c\PYZus{}type}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{n}{name}\PY{p}{,} \PY{n}{params}\PY{o}{=}\PY{n}{params}\PY{p}{,}
        \PY{n}{body}\PY{o}{=}\PY{n}{body}\PY{p}{,}
        \PY{n}{rel\PYZus{}path\PYZus{}to\PYZus{}Cparams}\PY{o}{=}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,} \PY{n}{loopopts} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AllPoints,Read\PYZus{}xxs}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Below we write the right-hand side evaluation function. We use
\href{https://en.wikipedia.org/wiki/Loop_nest_optimization}{\emph{loop
tiling}} for locality optimization.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}rhs\PYZus{}eval}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{desc}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Evaluate the scalar wave RHSs}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{includes} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}basic\PYZus{}defines.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}function\PYZus{}prototypes.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{k}{if} \PY{n}{enable\PYZus{}FD\PYZus{}functions}\PY{p}{:}
        \PY{n}{includes} \PY{o}{+}\PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{finite\PYZus{}difference\PYZus{}functions.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{k}{if} \PY{n}{enable\PYZus{}SIMD}\PY{p}{:}
        \PY{n}{includes} \PY{o}{+}\PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{SIMD/SIMD\PYZus{}intrinsics.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{n}{prefunc} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsh{}define IDX4ST(gf,i0,i1,i2) ( (i0) + tilesize\PYZus{}plus\PYZus{}2NGHOSTS0*( (i1) + tilesize\PYZus{}plus\PYZus{}2NGHOSTS1*( (i2) + tilesize\PYZus{}plus\PYZus{}2NGHOSTS2*(gf) ) ) )}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{c\PYZus{}type} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{void}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rhs\PYZus{}eval}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{params}   \PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{const paramstruct *restrict params, }\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{if} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
        \PY{n}{params} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{const rfm\PYZus{}struct *restrict rfmstruct, }\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{params} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{REAL *xx[3], }\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{params} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{const REAL *restrict in\PYZus{}gfs, REAL *restrict rhs\PYZus{}gfs}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{body} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{const int tilesize\PYZus{}total = tilesize\PYZus{}plus\PYZus{}2NGHOSTS0*tilesize\PYZus{}plus\PYZus{}2NGHOSTS1*tilesize\PYZus{}plus\PYZus{}2NGHOSTS2*NUM\PYZus{}EVOL\PYZus{}GFS;}
\PY{l+s+s2}{const int num\PYZus{}strides0 = Nxx0/tilesize0;}
\PY{l+s+s2}{const int num\PYZus{}strides1 = Nxx1/tilesize1;}
\PY{l+s+s2}{const int num\PYZus{}strides2 = Nxx2/tilesize2;}

\PY{l+s+s2}{// Tile loop}
\PY{l+s+s2}{\PYZsh{}pragma omp parallel for}
\PY{l+s+s2}{for(int stride2=0;stride2\PYZlt{}num\PYZus{}strides2;stride2++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{  const int idxshift2 = stride2 * tilesize2;}
\PY{l+s+s2}{  for(int stride1=0;stride1\PYZlt{}num\PYZus{}strides1;stride1++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{    const int idxshift1 = stride1 * tilesize1;}
\PY{l+s+s2}{    for(int stride0=0;stride0\PYZlt{}num\PYZus{}strides0;stride0++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{      const int idxshift0 = stride0 * tilesize0;}

\PY{l+s+s2}{      // Read from main memory}
\PY{l+s+s2}{      REAL in\PYZus{}tile[tilesize\PYZus{}total];}
\PY{l+s+s2}{      for(int gf=0;gf\PYZlt{}NUM\PYZus{}EVOL\PYZus{}GFS;gf++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{        for(int i2=0;i2\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS2;i2++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{          for(int i1=0;i1\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS1;i1++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{            for(int i0=0;i0\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS0;i0++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{              in\PYZus{}tile[IDX4ST(gf,i0,i1,i2)] = in\PYZus{}gfs[IDX4S(gf,i0+idxshift0,i1+idxshift1,i2+idxshift2)];}
\PY{l+s+s2}{            \PYZcb{} // for(int i0=0;i0\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS0;i0++)}
\PY{l+s+s2}{          \PYZcb{} // for(int i1=0;i1\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS1;i1++)}
\PY{l+s+s2}{        \PYZcb{} // for(int i2=0;i2\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS2;i2++)}
\PY{l+s+s2}{      \PYZcb{} // for(int gf=0;gf\PYZlt{}NUM\PYZus{}EVOL\PYZus{}GFS;gf++)}

\PY{l+s+s2}{      // Main loop}
\PY{l+s+s2}{      for(int it2=NGHOSTS;it2\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS2\PYZhy{}NGHOSTS;it2++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{        const int i2 = it2 + idxshift2;}
\PY{l+s+s2}{        \PYZsh{}include }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfm\PYZus{}files/rfm\PYZus{}struct\PYZus{}\PYZus{}read2.h}\PY{l+s+s2}{\PYZdq{}}
\PY{l+s+s2}{        for(int it1=NGHOSTS;it1\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS1\PYZhy{}NGHOSTS;it1++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{          const int i1 = it1 + idxshift1;}
\PY{l+s+s2}{          \PYZsh{}include }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfm\PYZus{}files/rfm\PYZus{}struct\PYZus{}\PYZus{}read1.h}\PY{l+s+s2}{\PYZdq{}}
\PY{l+s+s2}{          for(int it0=NGHOSTS;it0\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS0\PYZhy{}NGHOSTS;it0++) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{            const int i0 = it0 + idxshift0;}
\PY{l+s+s2}{            \PYZsh{}include }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rfm\PYZus{}files/rfm\PYZus{}struct\PYZus{}\PYZus{}read0.h}\PY{l+s+s2}{\PYZdq{}}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{o}{+}\PY{n}{fin}\PY{o}{.}\PY{n}{FD\PYZus{}outputC}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{returnstring}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{p}{[}\PY{n}{lhrh}\PY{p}{(}\PY{n}{lhs}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rhs\PYZus{}gfs[IDX4S(UUGF,i0+idxshift0,i1+idxshift1,i2+idxshift2)]}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{rhs}\PY{o}{=}\PY{n}{swrhs}\PY{o}{.}\PY{n}{uu\PYZus{}rhs}\PY{p}{)}\PY{p}{,}
                                   \PY{n}{lhrh}\PY{p}{(}\PY{n}{lhs}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rhs\PYZus{}gfs[IDX4S(VVGF,i0+idxshift0,i1+idxshift1,i2+idxshift2)]}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{rhs}\PY{o}{=}\PY{n}{swrhs}\PY{o}{.}\PY{n}{vv\PYZus{}rhs}\PY{p}{)}\PY{p}{]}\PY{p}{,}
                                   \PY{n}{params}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{preindent=6,includebraces=False,outCverbose=False,enable\PYZus{}SIMD=}\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{n+nb}{str}\PY{p}{(}\PY{n}{enable\PYZus{}SIMD}\PY{p}{)}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}
                                   \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{in\PYZus{}gfs[IDX4S}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{in\PYZus{}tile[IDX4ST}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}
                                   \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i0}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{it0}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{it1}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{i2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{it2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{          \PYZcb{} // for(int i0=NGHOSTS;i0\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS0\PYZhy{}NGHOSTS;i0++)}
\PY{l+s+s2}{        \PYZcb{} // for(int i1=NGHOSTS;i1\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS1\PYZhy{}NGHOSTS;i1++)}
\PY{l+s+s2}{      \PYZcb{} // for(int i2=NGHOSTS;i2\PYZlt{}tilesize\PYZus{}plus\PYZus{}2NGHOSTS2\PYZhy{}NGHOSTS;i2++)}

\PY{l+s+s2}{    \PYZcb{} // for(int stride0=0;stride0\PYZlt{}num\PYZus{}strides0;stride0++)}
\PY{l+s+s2}{  \PYZcb{} // for(int stride1=0;stride1\PYZlt{}num\PYZus{}strides1;stride1++)}
\PY{l+s+s2}{\PYZcb{} // for(int stride2=0;stride2\PYZlt{}num\PYZus{}strides2;stride2++) }
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{loopopts} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{c+c1}{\PYZsh{}     if enable\PYZus{}SIMD:}
\PY{c+c1}{\PYZsh{}         loopopts += \PYZdq{},enable\PYZus{}SIMD\PYZdq{}}
\PY{c+c1}{\PYZsh{}     if enable\PYZus{}rfm\PYZus{}precompute:}
\PY{c+c1}{\PYZsh{}         loopopts += \PYZdq{},enable\PYZus{}rfm\PYZus{}precompute\PYZdq{}}
\PY{c+c1}{\PYZsh{}     else:}
\PY{c+c1}{\PYZsh{}         loopopts += \PYZdq{},Read\PYZus{}xxs\PYZdq{}}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict}\PY{p}{(}
        \PY{n}{includes}\PY{o}{=}\PY{n}{includes}\PY{p}{,}
        \PY{n}{desc}\PY{o}{=}\PY{n}{desc}\PY{p}{,}\PY{n}{prefunc}\PY{o}{=}\PY{n}{prefunc}\PY{p}{,}
        \PY{n}{c\PYZus{}type}\PY{o}{=}\PY{n}{c\PYZus{}type}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{n}{name}\PY{p}{,} \PY{n}{params}\PY{o}{=}\PY{n}{params}\PY{p}{,}
        \PY{n}{body}\PY{o}{=}\PY{n}{body}\PY{p}{,}
        \PY{n}{rel\PYZus{}path\PYZus{}to\PYZus{}Cparams}\PY{o}{=}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,} \PY{n}{loopopts} \PY{o}{=} \PY{n}{loopopts}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-1.b-output-needed-c-code-for-boundary-condition-driver-back-to-top}{%
\subsection{\texorpdfstring{Step 1.b: Output needed C code for boundary
condition driver {[}Back to
\hyperref[toc]{top}{]}}{Step 1.b: Output needed C code for boundary condition driver {[}Back to {]}}}\label{step-1.b-output-needed-c-code-for-boundary-condition-driver-back-to-top}}

\[\label{boundaryconditions}\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{CurviBoundaryConditions}\PY{n+nn}{.}\PY{n+nn}{CurviBoundaryConditions\PYZus{}new\PYZus{}way} \PY{k}{as} \PY{n+nn}{CBC}
\PY{n}{CBC}\PY{o}{.}\PY{n}{CurviBoundaryConditions\PYZus{}register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{p}{)}
\PY{c+c1}{\PYZsh{} FIXME:}
\PY{c+c1}{\PYZsh{} if BoundaryCondition == \PYZdq{}Sommerfeld\PYZdq{}:}
\PY{c+c1}{\PYZsh{}     bcs = cbcs.sommerfeld\PYZus{}boundary\PYZus{}condition\PYZus{}class(fd\PYZus{}order=2,}
\PY{c+c1}{\PYZsh{}                                                  vars\PYZus{}radial\PYZus{}falloff\PYZus{}power\PYZus{}default=3,}
\PY{c+c1}{\PYZsh{}                                                  vars\PYZus{}speed\PYZus{}default=1.,}
\PY{c+c1}{\PYZsh{}                                                  vars\PYZus{}at\PYZus{}inf\PYZus{}default=0.)}
\PY{c+c1}{\PYZsh{}     \PYZsh{} bcs.vars\PYZus{}radpower.items()}
\PY{c+c1}{\PYZsh{}     bcs.write\PYZus{}sommerfeld\PYZus{}file(Ccodesrootdir)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Evolved gridfunction "uu" has parity type 0.
Evolved gridfunction "vv" has parity type 0.
    \end{Verbatim}

    \hypertarget{step-1.c-output-c-codes-needed-for-declaring-and-setting-cparameters-also-set-free_parameters.h-back-to-top}{%
\subsection{\texorpdfstring{Step 1.c: Output C codes needed for
declaring and setting Cparameters; also set \texttt{free\_parameters.h}
{[}Back to
\hyperref[toc]{top}{]}}{Step 1.c: Output C codes needed for declaring and setting Cparameters; also set free\_parameters.h {[}Back to {]}}}\label{step-1.c-output-c-codes-needed-for-declaring-and-setting-cparameters-also-set-free_parameters.h-back-to-top}}

\[\label{cparams_rfm_and_domainsize}\]

Here we output \texttt{free\_parameters.h}, which sets initial data
parameters, as well as grid domain \& reference metric parameters,
applying \texttt{domain\_size} and
\texttt{sinh\_width}/\texttt{SymTP\_bScale} (if applicable) as set above

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Step 1.c.i: Set free\PYZus{}parameters.h}
\PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{free\PYZus{}parameters.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
    \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{// Free parameters related to physical system:}
\PY{l+s+s2}{params.time = 0.0; // Initial simulation time corresponds to exact solution at time=0.}
\PY{l+s+s2}{params.wavespeed = 1.0;}

\PY{l+s+s2}{// Free parameters related to numerical timestep:}
\PY{l+s+s2}{REAL CFL\PYZus{}FACTOR = }\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{o}{+}\PY{n+nb}{str}\PY{p}{(}\PY{n}{CFL\PYZus{}FACTOR}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{;}

\PY{l+s+s2}{// Tile parameters}
\PY{l+s+s2}{params.tilesize0 = Nxx[0];}
\PY{l+s+s2}{params.tilesize1 = 1;}
\PY{l+s+s2}{params.tilesize2 = 1;}
\PY{l+s+s2}{params.tilesize\PYZus{}plus\PYZus{}2NGHOSTS0 = params.tilesize0 + 2*NGHOSTS;}
\PY{l+s+s2}{params.tilesize\PYZus{}plus\PYZus{}2NGHOSTS1 = params.tilesize1 + 2*NGHOSTS;}
\PY{l+s+s2}{params.tilesize\PYZus{}plus\PYZus{}2NGHOSTS2 = params.tilesize2 + 2*NGHOSTS;}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Append to \PYZdl{}Ccodesrootdir/free\PYZus{}parameters.h reference metric parameters based on generic}
\PY{c+c1}{\PYZsh{}    domain\PYZus{}size,sinh\PYZus{}width,sinhv2\PYZus{}const\PYZus{}dr,SymTP\PYZus{}bScale,}
\PY{c+c1}{\PYZsh{}    parameters set above.}
\PY{n}{rfm}\PY{o}{.}\PY{n}{out\PYZus{}default\PYZus{}free\PYZus{}parameters\PYZus{}for\PYZus{}rfm}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{free\PYZus{}parameters.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}
                                        \PY{n}{domain\PYZus{}size}\PY{p}{,}\PY{n}{sinh\PYZus{}width}\PY{p}{,}\PY{n}{sinhv2\PYZus{}const\PYZus{}dr}\PY{p}{,}\PY{n}{SymTP\PYZus{}bScale}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-1.d-output-needed-c-code-for-finding-the-minimum-proper-distance-between-grid-points-needed-for-cfl-limited-timestep-back-to-top}{%
\subsection{\texorpdfstring{Step 1.d: Output needed C code for finding
the minimum proper distance between grid points, needed for
\href{https://en.wikipedia.org/w/index.php?title=Courant\%E2\%80\%93Friedrichs\%E2\%80\%93Lewy_condition\&oldid=806430673}{CFL}-limited
timestep {[}Back to
\hyperref[toc]{top}{]}}{Step 1.d: Output needed C code for finding the minimum proper distance between grid points, needed for CFL-limited timestep {[}Back to {]}}}\label{step-1.d-output-needed-c-code-for-finding-the-minimum-proper-distance-between-grid-points-needed-for-cfl-limited-timestep-back-to-top}}

\[\label{cfl}\]

In order for our explicit-timestepping numerical solution to the scalar
wave equation to be stable, it must satisfy the
\href{https://en.wikipedia.org/w/index.php?title=Courant\%E2\%80\%93Friedrichs\%E2\%80\%93Lewy_condition\&oldid=806430673}{CFL}
condition: \[
\Delta t \le \frac{\min(ds_i)}{c},
\] where \(c\) is the wavespeed, and \[ds_i = h_i \Delta x^i\] is the
proper distance between neighboring gridpoints in the \(i\)th direction
(in 3D, there are 3 directions), \(h_i\) is the \(i\)th reference metric
scale factor, and \(\Delta x^i\) is the uniform grid spacing in the
\(i\)th direction:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Generate \PYZam{} register C function set\PYZus{}Nxx\PYZus{}dxx\PYZus{}invdx\PYZus{}params\PYZus{}\PYZus{}and\PYZus{}\PYZus{}xx()}
\PY{c+c1}{\PYZsh{} Generate \PYZam{} register C function xx\PYZus{}to\PYZus{}Cart() for}
\PY{c+c1}{\PYZsh{}               (the mapping from xx\PYZhy{}\PYZgt{}Cartesian) for the chosen}
\PY{c+c1}{\PYZsh{}               CoordSystem:}
\PY{c+c1}{\PYZsh{} Generate \PYZam{} register the find\PYZus{}timestep() function}
\PY{n}{rfm}\PY{o}{.}\PY{n}{register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{o}{=}\PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-2-the-c-code-main-function-for-scalarwavecurvilinear_playground-back-to-top}{%
\section{\texorpdfstring{Step 2: The C code \texttt{main()} function for
\texttt{ScalarWaveCurvilinear\_Playground} {[}Back to
\hyperref[toc]{top}{]}}{Step 2: The C code main() function for ScalarWaveCurvilinear\_Playground {[}Back to {]}}}\label{step-2-the-c-code-main-function-for-scalarwavecurvilinear_playground-back-to-top}}

\[\label{mainc}\]

Just as in \href{Tutorial-Start_to_Finish-ScalarWave.ipynb}{the
start-to-finish, solving the scalar wave equation in Cartesian
coordinates module}, we will implement the scalar wave equation via the
Method of Lines. As discussed above, the critical differences between
this code and the Cartesian version are as follows: 1. The
CFL-constrained timestep depends on the proper distance between
neighboring gridpoints 1. The boundary conditions must account for the
fact that ghost zone points lying in the domain exterior can map either
to the interior of the domain, or lie on the outer boundary. In the
former case, we simply copy the data from the interior. In the latter
case, we apply the usual outer boundary conditions. 1. The numerical
grids must be staggered to avoid direct evaluation of the equations on
coordinate singularities.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}main\PYZus{}\PYZus{}ScalarWaveCurvilinear\PYZus{}Playground}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{includes} \PY{o}{=} \PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}basic\PYZus{}defines.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{NRPy\PYZus{}function\PYZus{}prototypes.h}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}
    \PY{n}{desc} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}\PY{l+s+s2}{// main() function:}
\PY{l+s+s2}{// Step 0: Read command\PYZhy{}line input, set up grid structure, allocate memory for gridfunctions, set up coordinates}
\PY{l+s+s2}{// Step 1: Write test data to gridfunctions}
\PY{l+s+s2}{// Step 2: Overwrite all data in ghost zones with NaNs}
\PY{l+s+s2}{// Step 3: Apply curvilinear boundary conditions}
\PY{l+s+s2}{// Step 4: Print gridfunction data after curvilinear boundary conditions have been applied}
\PY{l+s+s2}{// Step 5: Free all allocated memory}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{c\PYZus{}type} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{int}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{name} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{main}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{params} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{int argc, const char *argv[]}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{body} \PY{o}{=} \PY{l+s+sa}{r}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{  paramstruct params;}
\PY{l+s+s2}{  set\PYZus{}Cparameters\PYZus{}to\PYZus{}default(\PYZam{}params);}

\PY{l+s+s2}{  // Step 0a: Read command\PYZhy{}line input, error out if nonconformant}
\PY{l+s+s2}{  if(argc != 4 || atoi(argv[1]) \PYZlt{} NGHOSTS || atoi(argv[2]) \PYZlt{} NGHOSTS || atoi(argv[3]) \PYZlt{} NGHOSTS) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Error: Expected one command\PYZhy{}line argument: ./ScalarWaveCurvilinear\PYZus{}Playground Nx0 Nx1 Nx2,}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{where Nx[0,1,2] is the number of grid points in the 0, 1, and 2 directions.}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Nx[] MUST BE larger than NGHOSTS (= }\PY{l+s+si}{\PYZpc{}d}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{,NGHOSTS);}
\PY{l+s+s2}{    exit(1);}
\PY{l+s+s2}{  \PYZcb{}}
\PY{l+s+s2}{  // Step 0b: Set up numerical grid structure, first in space...}
\PY{l+s+s2}{  const int Nxx[3] = }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{ atoi(argv[1]), atoi(argv[2]), atoi(argv[3]) \PYZcb{};}
\PY{l+s+s2}{  if(Nxx[0]}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{2 != 0 || Nxx[1]}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{2 != 0 || Nxx[2]}\PY{l+s+s2}{\PYZpc{}}\PY{l+s+s2}{2 != 0) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Error: Cannot guarantee a proper cell\PYZhy{}centered grid if number of grid cells not set to even number.}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{       For example, in case of angular directions, proper symmetry zones will not exist.}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    exit(1);}
\PY{l+s+s2}{  \PYZcb{}}

\PY{l+s+s2}{  // Step 0c: Set free parameters, overwriting Cparameters defaults}
\PY{l+s+s2}{  //          by hand or with command\PYZhy{}line input, as desired.}
\PY{l+s+s2}{\PYZsh{}include }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{free\PYZus{}parameters.h}\PY{l+s+s2}{\PYZdq{}}

\PY{l+s+s2}{  // Step 0d: Uniform coordinate grids are stored to *xx[3]}
\PY{l+s+s2}{  REAL *xx[3];}
\PY{l+s+s2}{  // Step 0d.i: Set bcstruct}
\PY{l+s+s2}{  bc\PYZus{}struct bcstruct;}
\PY{l+s+s2}{  }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{    int EigenCoord = 1;}
\PY{l+s+s2}{    // Step 0d.ii: Call set\PYZus{}Nxx\PYZus{}dxx\PYZus{}invdx\PYZus{}params\PYZus{}\PYZus{}and\PYZus{}\PYZus{}xx(), which sets}
\PY{l+s+s2}{    //             params Nxx,Nxx\PYZus{}plus\PYZus{}2NGHOSTS,dxx,invdx, and xx[] for the}
\PY{l+s+s2}{    //             chosen Eigen\PYZhy{}CoordSystem.}
\PY{l+s+s2}{    set\PYZus{}Nxx\PYZus{}dxx\PYZus{}invdx\PYZus{}params\PYZus{}\PYZus{}and\PYZus{}\PYZus{}xx(EigenCoord, Nxx, \PYZam{}params, xx);}
\PY{l+s+s2}{    // Step 0e: Find ghostzone mappings; set up bcstruct}
\PY{l+s+s2}{    driver\PYZus{}bcstruct(\PYZam{}params, \PYZam{}bcstruct, xx);}
\PY{l+s+s2}{    // Step 0e.i: Free allocated space for xx[][] array}
\PY{l+s+s2}{    for(int i=0;i\PYZlt{}3;i++) free(xx[i]);}
\PY{l+s+s2}{  \PYZcb{}}

\PY{l+s+s2}{  // Step 0f: Call set\PYZus{}Nxx\PYZus{}dxx\PYZus{}invdx\PYZus{}params\PYZus{}\PYZus{}and\PYZus{}\PYZus{}xx(), which sets}
\PY{l+s+s2}{  //          params Nxx,Nxx\PYZus{}plus\PYZus{}2NGHOSTS,dxx,invdx, and xx[] for the}
\PY{l+s+s2}{  //          chosen (non\PYZhy{}Eigen) CoordSystem.}
\PY{l+s+s2}{  int EigenCoord = 0;}
\PY{l+s+s2}{  set\PYZus{}Nxx\PYZus{}dxx\PYZus{}invdx\PYZus{}params\PYZus{}\PYZus{}and\PYZus{}\PYZus{}xx(EigenCoord, Nxx, \PYZam{}params, xx);}

\PY{l+s+s2}{  // Step 0g: Set all C parameters }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{blah}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ for params.blah, including}
\PY{l+s+s2}{  //          Nxx\PYZus{}plus\PYZus{}2NGHOSTS0 = params.Nxx\PYZus{}plus\PYZus{}2NGHOSTS0, etc.}
\PY{l+s+s2}{\PYZsh{}include }\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{set\PYZus{}Cparameters\PYZhy{}nopointer.h}\PY{l+s+s2}{\PYZdq{}}

\PY{l+s+s2}{  // Step 0h: Time coordinate parameters}
\PY{l+s+s2}{  const REAL t\PYZus{}final =  0.7*domain\PYZus{}size; /* Final time is set so that at t=t\PYZus{}final,}
\PY{l+s+s2}{                                          * data at the origin have not been corrupted}
\PY{l+s+s2}{                                          * by the approximate outer boundary condition */}

\PY{l+s+s2}{  // Step 0i: Set timestep based on smallest proper distance between gridpoints and CFL factor}
\PY{l+s+s2}{  REAL dt = find\PYZus{}timestep(\PYZam{}params, xx, CFL\PYZus{}FACTOR);}
\PY{l+s+s2}{  //printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZsh{} Timestep set to = }\PY{l+s+si}{\PYZpc{}e}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{,(double)dt);}
\PY{l+s+s2}{  int N\PYZus{}final = (int)(t\PYZus{}final / dt + 0.5); // The number of points in time.}
\PY{l+s+s2}{                                           // Add 0.5 to account for C rounding down}
\PY{l+s+s2}{                                           // typecasts to integers.}
\PY{l+s+s2}{  int output\PYZus{}every\PYZus{}N = (int)((REAL)N\PYZus{}final/800.0);}
\PY{l+s+s2}{  if(output\PYZus{}every\PYZus{}N == 0) output\PYZus{}every\PYZus{}N = 1;}

\PY{l+s+s2}{  // Step 0j: Error out if the number of auxiliary gridfunctions outnumber evolved gridfunctions.}
\PY{l+s+s2}{  //              This is a limitation of the RK method. You are always welcome to declare \PYZam{} allocate}
\PY{l+s+s2}{  //              additional gridfunctions by hand.}
\PY{l+s+s2}{  if(NUM\PYZus{}AUX\PYZus{}GFS \PYZgt{} NUM\PYZus{}EVOL\PYZus{}GFS) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Error: NUM\PYZus{}AUX\PYZus{}GFS \PYZgt{} NUM\PYZus{}EVOL\PYZus{}GFS. Either reduce the number of auxiliary gridfunctions,}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{       or allocate (malloc) by hand storage for *diagnostic\PYZus{}output\PYZus{}gfs. }\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{);}
\PY{l+s+s2}{    exit(1);}
\PY{l+s+s2}{  \PYZcb{}}

\PY{l+s+s2}{  // Step 0k: Declare struct for gridfunctions and allocate memory for y\PYZus{}n\PYZus{}gfs gridfunctions}
\PY{l+s+s2}{  MoL\PYZus{}gridfunctions\PYZus{}struct gridfuncs;}
\PY{l+s+s2}{  MoL\PYZus{}malloc\PYZus{}y\PYZus{}n\PYZus{}gfs(\PYZam{}params, \PYZam{}gridfuncs);}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{k}{if} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
        \PY{n}{body} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{  // Step 0l: Set up precomputed reference metric arrays}
\PY{l+s+s2}{  // Step 0l.i: Allocate space for precomputed reference metric arrays.}
\PY{l+s+s2}{  rfm\PYZus{}struct rfmstruct;}
\PY{l+s+s2}{  rfm\PYZus{}precompute\PYZus{}rfmstruct\PYZus{}malloc(\PYZam{}params, \PYZam{}rfmstruct);}

\PY{l+s+s2}{  // Step 0l.ii: Define precomputed reference metric arrays.}
\PY{l+s+s2}{  rfm\PYZus{}precompute\PYZus{}rfmstruct\PYZus{}define(\PYZam{}params, xx, \PYZam{}rfmstruct);}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{body} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{r}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}

\PY{l+s+s2}{  // Step 1: Set up initial data to be exact solution at time=0:}
\PY{l+s+s2}{  params.time = 0.0; exact\PYZus{}solution\PYZus{}all\PYZus{}points(\PYZam{}params, xx, gridfuncs.y\PYZus{}n\PYZus{}gfs);}

\PY{l+s+s2}{  // Step 1a: Allocate memory for non y\PYZus{}n\PYZus{}gfs. We do this here to free up}
\PY{l+s+s2}{  //         memory for setting up initial data (for cases in which initial}
\PY{l+s+s2}{  //         data setup is memory intensive.)}
\PY{l+s+s2}{  MoL\PYZus{}malloc\PYZus{}non\PYZus{}y\PYZus{}n\PYZus{}gfs(\PYZam{}params, \PYZam{}gridfuncs);}

\PY{l+s+s2}{  for(int n=0;n\PYZlt{}=N\PYZus{}final;n++)}
\PY{l+s+s2}{    }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{ // Main loop to progress forward in time.}

\PY{l+s+s2}{    // Step 1a: Set current time to correct value \PYZam{} compute exact solution}
\PY{l+s+s2}{    params.time = ((REAL)n)*dt;}

\PY{l+s+s2}{    // Step 2: Code validation: Compute log of L2 norm of difference}
\PY{l+s+s2}{    //         between numerical and exact solutions:}
\PY{l+s+s2}{    //   log\PYZus{}L2\PYZus{}Norm = log10( sqrt[Integral( [numerical \PYZhy{} exact]\PYZca{}2 * dV)] ),}
\PY{l+s+s2}{    //         where integral is within 30}\PY{l+s+si}{\PYZpc{} o}\PY{l+s+s2}{f the grid outer boundary (domain\PYZus{}size)}
\PY{l+s+s2}{    if(n}\PY{l+s+si}{\PYZpc{}o}\PY{l+s+s2}{utput\PYZus{}every\PYZus{}N == 0) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{      REAL integral = 0.0;}
\PY{l+s+s2}{      REAL numpts   = 0.0;}
\PY{l+s+s2}{\PYZsh{}pragma omp parallel for reduction(+:integral,numpts)}
\PY{l+s+s2}{      LOOP\PYZus{}REGION(NGHOSTS,Nxx\PYZus{}plus\PYZus{}2NGHOSTS0\PYZhy{}NGHOSTS,}
\PY{l+s+s2}{                  NGHOSTS,Nxx\PYZus{}plus\PYZus{}2NGHOSTS1\PYZhy{}NGHOSTS,}
\PY{l+s+s2}{                  NGHOSTS,Nxx\PYZus{}plus\PYZus{}2NGHOSTS2\PYZhy{}NGHOSTS) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{        REAL xCart[3]; xx\PYZus{}to\PYZus{}Cart(\PYZam{}params,xx,i0,i1,i2, xCart);}
\PY{l+s+s2}{        if(sqrt(xCart[0]*xCart[0] + xCart[1]*xCart[1] + xCart[2]*xCart[2]) \PYZlt{} domain\PYZus{}size*0.3) }\PY{l+s+s2}{\PYZob{}}
\PY{l+s+s2}{          REAL uu\PYZus{}exact,vv\PYZus{}exact; exact\PYZus{}solution\PYZus{}single\PYZus{}point(\PYZam{}params, xx[0][i0],xx[1][i1],xx[2][i2],}
\PY{l+s+s2}{                                                              \PYZam{}uu\PYZus{}exact,\PYZam{}vv\PYZus{}exact);}
\PY{l+s+s2}{          double num   = (double)gridfuncs.y\PYZus{}n\PYZus{}gfs[IDX4S(UUGF,i0,i1,i2)];}
\PY{l+s+s2}{          double exact = (double)uu\PYZus{}exact;}
\PY{l+s+s2}{          integral += (num \PYZhy{} exact)*(num \PYZhy{} exact);}
\PY{l+s+s2}{          numpts   += 1.0;}
\PY{l+s+s2}{        \PYZcb{}}
\PY{l+s+s2}{      \PYZcb{}}
\PY{l+s+s2}{      // Compute and output the log of the L2 norm.}
\PY{l+s+s2}{      REAL log\PYZus{}L2\PYZus{}Norm = log10(1e\PYZhy{}16 + sqrt(integral/numpts));  // 1e\PYZhy{}16 + ... avoids log10(0)}
\PY{l+s+s2}{      printf(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZpc{}e}\PY{l+s+s2}{ }\PY{l+s+si}{\PYZpc{}e}\PY{l+s+s2}{\PYZbs{}}\PY{l+s+s2}{n}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{,(double)params.time,log\PYZus{}L2\PYZus{}Norm);}
\PY{l+s+s2}{    \PYZcb{}}

\PY{l+s+s2}{    // Step 3: Evolve scalar wave initial data forward in time using Method of Lines with RK4 algorithm,}
\PY{l+s+s2}{    //         applying quadratic extrapolation outer boundary conditions.}
\PY{l+s+s2}{    // Step 3.b: Step forward one timestep (t \PYZhy{}\PYZgt{} t+dt) in time using}
\PY{l+s+s2}{    //           chosen RK\PYZhy{}like MoL timestepping algorithm}
\PY{l+s+s2}{    MoL\PYZus{}step\PYZus{}forward\PYZus{}in\PYZus{}time(\PYZam{}params, \PYZam{}rfmstruct, \PYZam{}bcstruct, \PYZam{}gridfuncs, dt);}

\PY{l+s+s2}{  \PYZcb{} // End main loop to progress forward in time.}

\PY{l+s+s2}{  // Step 4: Free all allocated memory}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{k}{if} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
        \PY{n}{body} \PY{o}{+}\PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  rfm\PYZus{}precompute\PYZus{}rfmstruct\PYZus{}freemem(\PYZam{}params, \PYZam{}rfmstruct);}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}
    \PY{n}{body} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{r}\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
\PY{l+s+s2}{  freemem\PYZus{}bcstruct(\PYZam{}params, \PYZam{}bcstruct);}
\PY{l+s+s2}{  MoL\PYZus{}free\PYZus{}memory\PYZus{}y\PYZus{}n\PYZus{}gfs(\PYZam{}params, \PYZam{}gridfuncs);}
\PY{l+s+s2}{  MoL\PYZus{}free\PYZus{}memory\PYZus{}non\PYZus{}y\PYZus{}n\PYZus{}gfs(\PYZam{}params, \PYZam{}gridfuncs);}
\PY{l+s+s2}{  for(int i=0;i\PYZlt{}3;i++) free(xx[i]);}
\PY{l+s+s2}{  return 0;}
\PY{l+s+s2}{\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{c+c1}{\PYZsh{} As rfmstruct stores functions of xx, when rfm\PYZus{}precompute is disabled,}
    \PY{c+c1}{\PYZsh{}   we always pass xx to a function instead of \PYZam{}rfmstruct.}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{enable\PYZus{}rfm\PYZus{}precompute}\PY{p}{:}
        \PY{n}{body} \PY{o}{=} \PY{n}{body}\PY{o}{.}\PY{n}{replace}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZam{}rfmstruct}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{xx}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict}\PY{p}{(}
        \PY{n}{includes}\PY{o}{=}\PY{n}{includes}\PY{p}{,}
        \PY{n}{desc}\PY{o}{=}\PY{n}{desc}\PY{p}{,}
        \PY{n}{c\PYZus{}type}\PY{o}{=}\PY{n}{c\PYZus{}type}\PY{p}{,} \PY{n}{name}\PY{o}{=}\PY{n}{name}\PY{p}{,} \PY{n}{params}\PY{o}{=}\PY{n}{params}\PY{p}{,}
        \PY{n}{body}\PY{o}{=}\PY{n}{body}\PY{p}{,}
        \PY{n}{rel\PYZus{}path\PYZus{}to\PYZus{}Cparams}\PY{o}{=}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,} \PY{n}{enableCparameters}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Next, register all remaining C functions in
\texttt{outC\_function\_dict}, and output
\texttt{finite\_difference\_functions.h}. Also construct
\texttt{NRPy\_basic\_defines.h}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{register\PYZus{}C\PYZus{}code\PYZus{}functions\PYZus{}ScalarWaveCurvilinear}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}exact\PYZus{}solution\PYZus{}single\PYZus{}point}\PY{p}{(}\PY{p}{)}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}exact\PYZus{}solution\PYZus{}all\PYZus{}points}\PY{p}{(}\PY{p}{)}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}rhs\PYZus{}eval}\PY{p}{(}\PY{p}{)}
    \PY{n}{add\PYZus{}to\PYZus{}Cfunction\PYZus{}dict\PYZus{}main\PYZus{}\PYZus{}ScalarWaveCurvilinear\PYZus{}Playground}\PY{p}{(}\PY{p}{)}

\PY{k+kn}{import} \PY{n+nn}{outputC} \PY{k}{as} \PY{n+nn}{outC}
\PY{n}{outC}\PY{o}{.}\PY{n}{outputC\PYZus{}register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{p}{)}  \PY{c+c1}{\PYZsh{} \PYZsh{}define M\PYZus{}PI,  etc.}
\PY{c+c1}{\PYZsh{} Declare paramstruct, register set\PYZus{}Cparameters\PYZus{}to\PYZus{}default(),}
\PY{c+c1}{\PYZsh{}   and output declare\PYZus{}Cparameters\PYZus{}struct.h and set\PYZus{}Cparameters[].h:}
\PY{n}{outC}\PY{o}{.}\PY{n}{NRPy\PYZus{}param\PYZus{}funcs\PYZus{}register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{)}\PY{p}{)}

\PY{n}{gri}\PY{o}{.}\PY{n}{register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{p}{)}  \PY{c+c1}{\PYZsh{} \PYZsh{}define IDX3S(),  etc.}
\PY{n}{fin}\PY{o}{.}\PY{n}{register\PYZus{}C\PYZus{}functions\PYZus{}and\PYZus{}NRPy\PYZus{}basic\PYZus{}defines}\PY{p}{(}\PY{n}{NGHOSTS\PYZus{}account\PYZus{}for\PYZus{}onezone\PYZus{}upwind}\PY{o}{=}\PY{k+kc}{False}\PY{p}{)}  \PY{c+c1}{\PYZsh{} \PYZsh{}define NGHOSTS, etc.}

\PY{c+c1}{\PYZsh{} all functions needed for scalar wave:}
\PY{n}{register\PYZus{}C\PYZus{}code\PYZus{}functions\PYZus{}ScalarWaveCurvilinear}\PY{p}{(}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Output functions for computing all finite\PYZhy{}difference stencils.}
\PY{c+c1}{\PYZsh{}   Must be called after defining all functions depending on FD stencils.}
\PY{k}{if} \PY{n}{enable\PYZus{}FD\PYZus{}functions}\PY{p}{:}
    \PY{n}{fin}\PY{o}{.}\PY{n}{output\PYZus{}finite\PYZus{}difference\PYZus{}functions\PYZus{}h}\PY{p}{(}\PY{n}{path}\PY{o}{=}\PY{n}{Ccodesrootdir}\PY{p}{)}

\PY{c+c1}{\PYZsh{} Call this last: Set up NRPy\PYZus{}basic\PYZus{}defines.h and NRPy\PYZus{}function\PYZus{}prototypes.h.}
\PY{n}{outC}\PY{o}{.}\PY{n}{construct\PYZus{}NRPy\PYZus{}basic\PYZus{}defines\PYZus{}h}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{n}{enable\PYZus{}SIMD}\PY{o}{=}\PY{n}{enable\PYZus{}SIMD}\PY{p}{)}
\PY{n}{outC}\PY{o}{.}\PY{n}{construct\PYZus{}NRPy\PYZus{}function\PYZus{}prototypes\PYZus{}h}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{step-3-compile-generated-c-codes-solve-the-scalar-wave-equation-back-to-top}{%
\section{\texorpdfstring{Step 3: Compile generated C codes \& solve the
scalar wave equation {[}Back to
\hyperref[toc]{top}{]}}{Step 3: Compile generated C codes \& solve the scalar wave equation {[}Back to {]}}}\label{step-3-compile-generated-c-codes-solve-the-scalar-wave-equation-back-to-top}}

\[\label{compileexec}\]

To aid in the cross-platform-compatible (with Windows, MacOS, \& Linux)
compilation and execution, we make use of \texttt{cmdline\_helper}
\href{Tutorial-cmdline_helper.ipynb}{(\textbf{Tutorial})}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{cmdline\PYZus{}helper} \PY{k}{as} \PY{n+nn}{cmd}
\PY{n}{cmd}\PY{o}{.}\PY{n}{new\PYZus{}C\PYZus{}compile}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ScalarWaveCurvilinear\PYZus{}Playground}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
                  \PY{n}{uses\PYZus{}free\PYZus{}parameters\PYZus{}h}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{compiler\PYZus{}opt\PYZus{}option}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{fast}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{c+c1}{\PYZsh{} fastdebug or debug also supported}
\PY{n}{os}\PY{o}{.}\PY{n}{chdir}\PY{p}{(}\PY{n}{Ccodesrootdir}\PY{p}{)}
\PY{n}{cmd}\PY{o}{.}\PY{n}{Execute}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ScalarWaveCurvilinear\PYZus{}Playground}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{16  8 16}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{out\PYZhy{}lowresolution.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{cmd}\PY{o}{.}\PY{n}{Execute}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ScalarWaveCurvilinear\PYZus{}Playground}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{24 12 24}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{output}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{out\PYZhy{}medresolution.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Return to root directory}
\PY{n}{os}\PY{o}{.}\PY{n}{chdir}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{..}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
(EXEC): Executing `make -j10`{\ldots}
(BENCH): Finished executing in 1.8473269939422607 seconds.
Finished compilation.
(EXEC): Executing `./ScalarWaveCurvilinear\_Playground 16  8 16`{\ldots}
(BENCH): Finished executing in 0.8285930156707764 seconds.
(EXEC): Executing `./ScalarWaveCurvilinear\_Playground 24 12 24`{\ldots}
(BENCH): Finished executing in 2.429636001586914 seconds.
    \end{Verbatim}

    \hypertarget{step-4-code-validation-plot-the-numerical-error-and-confirm-that-it-converges-to-zero-at-expected-rate-with-increasing-numerical-resolution-sampling-back-to-top}{%
\section{\texorpdfstring{Step 4: Code validation: Plot the numerical
error, and confirm that it converges to zero at expected rate with
increasing numerical resolution (sampling) {[}Back to
\hyperref[toc]{top}{]}}{Step 4: Code validation: Plot the numerical error, and confirm that it converges to zero at expected rate with increasing numerical resolution (sampling) {[}Back to {]}}}\label{step-4-code-validation-plot-the-numerical-error-and-confirm-that-it-converges-to-zero-at-expected-rate-with-increasing-numerical-resolution-sampling-back-to-top}}

\[\label{convergence}\] The numerical solution
\(u_{\rm num}(x0,x1,x2,t)\) should converge to the exact solution
\(u_{\rm exact}(x0,x1,x2,t)\) at fourth order, which means that \[
u_{\rm num}(x0,x1,x2,t) = u_{\rm exact}(x0,x1,x2,t) + \mathcal{O}\left((\Delta x0)^4\right)+ \mathcal{O}\left((\Delta x1)^4\right)+ \mathcal{O}\left((\Delta x2)^4\right)+ \mathcal{O}\left((\Delta t)^4\right).
\]

Thus the relative error \(E_{\rm rel}\) should satisfy: \[
\left|\frac{u_{\rm num}(x0,x1,x2,t) - u_{\rm exact}(x0,x1,x2,t)}{u_{\rm exact}(x0,x1,x2,t)}\right| + \mathcal{O}\left((\Delta x0)^4\right)+ \mathcal{O}\left((\Delta x1)^4\right)+ \mathcal{O}\left((\Delta x2)^4\right)+ \mathcal{O}\left((\Delta t)^4\right).
\]

We confirm this convergence behavior by first solving the scalar wave
equation at two resolutions: \(16\times 8\times 16\) (or \(16^3\) if
\texttt{reference\_metric::CoordSystem} is set to \texttt{Cartesian}),
and \(24\times 12\times 24\) (or \(24^3\) if
\texttt{reference\_metric::CoordSystem} is set to \texttt{Cartesian})
and evaluating the maximum logarithmic relative error
\(\log_{10} E_{\rm rel,max}\) between numerical and exact solutions
within a region \(R < 0.1 {\rm RMAX}\) at all iterations.

Since we increase the resolution uniformly over all four coordinates
\((x0,x1,x2,t)\), \(E_{\rm rel}\) should drop uniformly as
\((\Delta x0)^4\): \[
E_{\rm rel} \propto (\Delta x0)^4.
\]

So at the two resolutions, we should find that \[
\frac{E_{\rm rel}(16\times 8\times 16)}{E_{\rm rel}(24\times 12\times 24)} = \frac{E_{\rm rel}(16^3)}{E_{\rm rel}(24^3)} \approx \left(\frac{(\Delta x0)_{16}}{(\Delta x0)_{24}}\right)^{4} = \left(\frac{24}{16}\right)^4 \approx 5.
\]

Since we're measuring logarithmic relative error, this should be \[
\log_{10}\left(\frac{E_{\rm rel}(16\times 8\times 16)}{E_{\rm rel}(24\times 12\times 24)}\right) = \log_{10}\left(\frac{E_{\rm rel}(16^3)}{E_{\rm rel}(24^3)}\right) \approx \log_{10}(5).
\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{k+kn}{import} \PY{n+nn}{mpmath} \PY{k}{as} \PY{n+nn}{mp}
\PY{k+kn}{import} \PY{n+nn}{csv}

\PY{k}{def} \PY{n+nf}{file\PYZus{}reader}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{filename}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{reader} \PY{o}{=} \PY{n}{csv}\PY{o}{.}\PY{n}{reader}\PY{p}{(}\PY{n}{file}\PY{p}{,} \PY{n}{delimiter}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ }\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{data}  \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{zip}\PY{p}{(}\PY{o}{*}\PY{n}{reader}\PY{p}{)}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} data is a tuple of strings. Tuples are immutable, and we need to perform math on}
        \PY{c+c1}{\PYZsh{}   the data, so here we convert tuple to lists of floats:}
        \PY{n}{data0} \PY{o}{=} \PY{p}{[}\PY{p}{]}
        \PY{n}{data1} \PY{o}{=} \PY{p}{[}\PY{p}{]}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{n}{data0}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{float}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}
            \PY{n}{data1}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb}{float}\PY{p}{(}\PY{n}{data}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}
        \PY{k}{return} \PY{n}{data0}\PY{p}{,}\PY{n}{data1}

\PY{n}{first\PYZus{}col16}\PY{p}{,}\PY{n}{second\PYZus{}col16} \PY{o}{=} \PY{n}{file\PYZus{}reader}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{outdir}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{out\PYZhy{}lowresolution.txt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
\PY{n}{first\PYZus{}col24}\PY{p}{,}\PY{n}{second\PYZus{}col24} \PY{o}{=} \PY{n}{file\PYZus{}reader}\PY{p}{(}\PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{outdir}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{out\PYZhy{}medresolution.txt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}

\PY{n}{second\PYZus{}col16\PYZus{}rescaled4o} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{second\PYZus{}col16\PYZus{}rescaled5o} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{second\PYZus{}col16}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} data16 = data24*(16/24)**4}
    \PY{c+c1}{\PYZsh{} \PYZhy{}\PYZgt{} log10(data24) = log10(data24) + 4*log10(16/24)}
    \PY{n}{second\PYZus{}col16\PYZus{}rescaled4o}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{second\PYZus{}col16}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{4}\PY{o}{*}\PY{n}{mp}\PY{o}{.}\PY{n}{log10}\PY{p}{(}\PY{l+m+mf}{16.}\PY{o}{/}\PY{l+m+mf}{24.}\PY{p}{)}\PY{p}{)}
    \PY{n}{second\PYZus{}col16\PYZus{}rescaled5o}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{second\PYZus{}col16}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{5}\PY{o}{*}\PY{n}{mp}\PY{o}{.}\PY{n}{log10}\PY{p}{(}\PY{l+m+mf}{16.}\PY{o}{/}\PY{l+m+mf}{24.}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} https://matplotlib.org/gallery/text\PYZus{}labels\PYZus{}and\PYZus{}annotations/legend.html\PYZsh{}sphx\PYZhy{}glr\PYZhy{}gallery\PYZhy{}text\PYZhy{}labels\PYZhy{}and\PYZhy{}annotations\PYZhy{}legend\PYZhy{}py}
\PY{n}{fig}\PY{p}{,} \PY{n}{ax} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{subplots}\PY{p}{(}\PY{p}{)}

\PY{n}{plt}\PY{o}{.}\PY{n}{title}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Demonstrating 4th\PYZhy{}order Convergence: }\PY{l+s+s2}{\PYZdq{}}\PY{o}{+}\PY{n}{par}\PY{o}{.}\PY{n}{parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::CoordSystem}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{o}{+}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ Coordinates}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{time}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{log10(Max relative error)}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{first\PYZus{}col24}\PY{p}{,} \PY{n}{second\PYZus{}col24}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{logErel(N0=24)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{first\PYZus{}col16}\PY{p}{,} \PY{n}{second\PYZus{}col16\PYZus{}rescaled4o}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k\PYZhy{}\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{logErel(N0=16) + log((16/24)\PYZca{}4)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylim}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{8.05}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.7}\PY{p}{]}\PY{p}{)} \PY{c+c1}{\PYZsh{} Manually set the y\PYZhy{}axis range case, since the log10}
                          \PY{c+c1}{\PYZsh{} relative error at t=0 could be \PYZhy{}inf or about \PYZhy{}16,}
                          \PY{c+c1}{\PYZsh{} resulting in very different\PYZhy{}looking plots}
                          \PY{c+c1}{\PYZsh{} despite the data being the same to roundoff.}
\PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::CoordSystem}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cartesian}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
    \PY{n}{ax}\PY{o}{.}\PY{n}{set\PYZus{}ylim}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mf}{2.68}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.62}\PY{p}{]}\PY{p}{)}
\PY{k}{if} \PY{n}{par}\PY{o}{.}\PY{n}{parval\PYZus{}from\PYZus{}str}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{reference\PYZus{}metric::CoordSystem}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{o}{==} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cylindrical}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:}
    \PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{first\PYZus{}col16}\PY{p}{,} \PY{n}{second\PYZus{}col16\PYZus{}rescaled5o}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{k.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}  \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{(Assuming 5th\PYZhy{}order convergence)}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{legend} \PY{o}{=} \PY{n}{ax}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{n}{loc}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{lower right}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{shadow}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{fontsize}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{large}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{legend}\PY{o}{.}\PY{n}{get\PYZus{}frame}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{set\PYZus{}facecolor}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{C1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{Tutorial-Start_to_Finish-ScalarWaveCurvilinear_with_loop_tiling_new_way_files/Tutorial-Start_to_Finish-ScalarWaveCurvilinear_with_loop_tiling_new_way_25_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \hypertarget{step-5-output-this-notebook-to-latex-formatted-pdf-file-back-to-top}{%
\section{\texorpdfstring{Step 5: Output this notebook to
\(\LaTeX\)-formatted PDF file {[}Back to
\hyperref[toc]{top}{]}}{Step 5: Output this notebook to \textbackslash LaTeX-formatted PDF file {[}Back to {]}}}\label{step-5-output-this-notebook-to-latex-formatted-pdf-file-back-to-top}}

\[\label{latex_pdf_output}\]

The following code cell converts this Jupyter notebook into a proper,
clickable \(\LaTeX\)-formatted PDF file. After the cell is successfully
run, the generated PDF may be found in the root NRPy+ tutorial
directory, with filename
\url{Tutorial-Start_to_Finish-ScalarWaveCurvilinear_with_loop_tiling_new_way.pdf}
(Note that clicking on this link may not work; you may need to open the
PDF file through another means.)

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{cmdline\PYZus{}helper} \PY{k}{as} \PY{n+nn}{cmd}    \PY{c+c1}{\PYZsh{} NRPy+: Multi\PYZhy{}platform Python command\PYZhy{}line interface}
\PY{n}{cmd}\PY{o}{.}\PY{n}{output\PYZus{}Jupyter\PYZus{}notebook\PYZus{}to\PYZus{}LaTeXed\PYZus{}PDF}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Tutorial\PYZhy{}Start\PYZus{}to\PYZus{}Finish\PYZhy{}ScalarWaveCurvilinear\PYZus{}with\PYZus{}loop\PYZus{}tiling\PYZus{}new\PYZus{}way}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Created Tutorial-Start\_to\_Finish-
    ScalarWaveCurvilinear\_with\_loop\_tiling\_new\_way.tex, and compiled LaTeX
    file to PDF file Tutorial-Start\_to\_Finish-
    ScalarWaveCurvilinear\_with\_loop\_tiling\_new\_way.pdf
    \end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
